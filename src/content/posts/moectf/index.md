---
title: moectf2025逆向方向个人wp（17/17）
date: 2025-12-25
tags: [CTF, wp, moectf, re]
category: CTF
published: 2025-12-25
updated: 2025-12-25
description: AK结束了3个月的新生赛也算AK
---

# 00 后记

**moectf 2025**是本人入坑ctf以来的第一场比赛，而在入门的三个月后，终于将给出*鸽了很长时间*的逆向方向个人wp。

# 01 speed

打开程序发现窗口消失很快；

ida分析主窗口程序，发现sleep时间太短；

![image-20251218120117235](./image-20251218120117235.png)

直接给destory这一行前下断点，即可保留窗口；

![image-20251218120307626](./image-20251218120307626.png)

**moectf{Just_dyn@mic_d3bugg1ng}**



# 02 逆向工程入门指北

main中直接找到flag；

![image-20251218120654924](./image-20251218120654924.png)

**moectf{open_your_IDA_and_start_reverse_engineering!!}**



# 03 base

常规base64；

![image-20251218121111249](./image-20251218121111249.png)

![image-20251218121053525](./image-20251218121053525.png)

![image-20251218121034589](./image-20251218121034589.png)

直接cyberchef；

![image-20251218121217985](./image-20251218121217985.png)

**moectf{Y0u_C4n_G00d_At_B45e64!!}**

# 04 catch

![image-20251218121532560](./image-20251218121532560.png)

必然抛出异常，汇编找catch块；

明显主程序在这，但是反汇编不出来；

![image-20251218122151942](./image-20251218122151942.png)

直接把try块（其实在哪改都行）中的抛出异常patch成jmp到catch块即可反编译；

![image-20251218122258710](./image-20251218122258710.png)

![image-20251218122309236](./image-20251218122309236.png)

ROT13,即对大小写处理不同的凯撒，cyberchef解desuwa；

![image-20251218122533170](./image-20251218122533170.png)

**moectf{S4m3_Tr1ck_with_@flower_desuwa}**

# 05 ezandroid

base64;

![image-20251215221954343](./image-20251215221954343.png)

![image-20251215222140836](./image-20251215222140836.png)

**moectf{android_Reverse_I5_easy}**

# 06 ez3

前面检验长度，格式

![image-20251215222427528](./image-20251215222427528.png)

主要函数![image-20251215234005173](./image-20251215234005173.png)

有取模不能正常逆向，结合题目考虑z3求解器；

注意行7最后的`+i`在解指针外面是实际值，`b[i]`到最后就是cipher；

```py
from z3 import *

cipher = [
    0x0000B1B0, 0x00005678, 0x00007FF2, 0x0000A332, 0x0000A0E8, 0x0000364C,
    0x00002BD4, 0x0000C8FE, 0x00004A7C, 0x00000018, 0x00002BE4, 0x00004144,
    0x00003BA6, 0x0000BE8C, 0x00008F7E, 0x000035F8, 0x000061AA, 0x00002B4A,
    0x00006828, 0x0000B39E, 0x0000B542, 0x000033EC, 0x0000C7D8, 0x0000448C,
    0x00009310, 0x00008808, 0x0000ADD4, 0x00003CC2, 0x00000796, 0x0000C940,
    0x00004E32, 0x00004E2E, 0x0000924A, 0x00005B5C
]

x = [BitVec(f'x[{i}]', 32) for i in range(34)]

s = Solver()

for i in range(34):
    s.add(x[i] >= 32, x[i] <= 126)

s.add(cipher[0] == ((x[0] + 0) * 47806) % 51966)

for i in range(1, 34):
    s.add(cipher[i] == (((x[i] + i) * 47806) ^ cipher[i-1] ^ 0x114514) % 51966)

if s.check() == sat:
    m = s.model()
    vals = [m[x[i]].as_long() for i in range(34)]
    flag = ''.join(chr(v) for v in vals)
    print("Flag:", flag)
else:
    print("No solution")
```

**moectf{Y0u_Kn0w_z3_S0Iv3r_N0w_a1f2bdce4a9}**



# 07 2048_master_re

exe打开是个2048游戏，提示到16384出flag；

字符串查找到关键函数，可以发现`n13>13`时，即玩到16384时执行下面的分支；

![image-20251217162920164](./image-20251217162920164.png)

点进去很乱难以静态分析，尝试patch改判断条件；

将jle改为jge，即将`n13>13`改为`n13<13`，再运行即出flag。

![image-20251217162741800](./image-20251217162741800.png)

![image-20251217163103140](./image-20251217163103140.png)

**moectf{Y0u_4re_a_2048_m4st3r!!!!r0erowhu}**

交不上去，原来这是一个misc的解，不让patch，要找解密T T；

好吧，开始找flag.txt的交叉引用，找到这样的加密；

![image-20251217164908310](./image-20251217164908310.png)

xxtea；只改了DELTA;

![image-20251217164912655](./image-20251217164912655.png)

```CPP
#include <cstdint>
#include <vector>
#include <array>
#include <iostream>
#include <iomanip>

void xxtea_decrypt(uint32_t* v, size_t n, const uint32_t* k) {
    const uint32_t DELTA = 0x3E9779B9;
    uint32_t rounds = 6 + 52 / n;
    uint32_t sum = rounds * DELTA;
    uint32_t y, z;  
    
    y = v[0];  
    while (rounds--) {
        uint32_t e = (sum >> 2) & 3;
        for (unsigned p = (unsigned)n - 1; p > 0; --p) {
            z = v[p - 1];
            y = v[p] -= (((z >> 5) ^ (y << 2)) + ((y >> 3) ^ (z << 4)))
                         ^ ((sum ^ y) + (k[(p & 3) ^ e] ^ z));
        }
        z = v[n - 1];
        y = v[0] -= (((z >> 5) ^ (y << 2)) + ((y >> 3) ^ (z << 4)))
                     ^ ((sum ^ y) + (k[(0 & 3) ^ e] ^ z));
        sum -= DELTA;
    }
}


int main() {
uint32_t data[10] = {
    0xCC777935, 0x3441131B, 0x919FFFF9, 0x78945BFF,
    0xAEAF2A86, 0x4D319ED7, 0x51A5C47A, 0x446ED9D1,
    0x1B865218, 0x63C98A42
};
uint8_t key[17] = "2048master2048ma";

xxtea_decrypt(data, 10, (uint32_t*)key);

for (int i = 0; i < sizeof(data)/sizeof(data[0])*4; ++i) {
    std::cout << *(uint8_t*)((uint8_t*)data + i);
}
std::cout << std::endl;
}
```

**moectf{@_N1c3_cup_0f_XXL_te4_1n_2O48}**

# 08 A cup of tea

tea加密，改了DELTA，v5是明文，v6是密文；

![image-20251218111809683](./image-20251218111809683.png)

![image-20251218111825268](./image-20251218111825268.png)

```cpp
#include <iostream>
#include <cstdint>
#include <cstring>
#include <vector>
using namespace std;

// TEA 加密函数：对一个 64-bit（两个 uint32_t）块进行加密
void TEA_encrypt(uint32_t* v, const uint32_t* key) {
  uint32_t v0 = v[0], v1 = v[1];     // 拆分为两个 32-bit 的部分
  uint32_t sum = 0;
  const uint32_t delta = 0x114514;   // 一个常用的“魔数”，用于扰乱加密过程
  // TEA 进行 32 轮加密
  for (int i = 0; i < 32; ++i) {
    sum += delta;
    v0 += ((v1 << 4) + key[0]) ^ (v1 + sum) ^ ((v1 >> 5) + key[1]);
    v1 += ((v0 << 4) + key[2]) ^ (v0 + sum) ^ ((v0 >> 5) + key[3]);
  }
  v[0] = v0;
  v[1] = v1;
}

// TEA 解密函数：对一个 64-bit 块进行解密
void TEA_decrypt(uint32_t* v, const uint32_t* key) {
  uint32_t v0 = v[0], v1 = v[1];
  const uint32_t delta = 0x114514;
  uint32_t sum = delta * 32;  // 初始 sum 是加密时累加的最终值
  // TEA 进行 32 轮解密（加密的逆过程）
  for (int i = 0; i < 32; ++i) {
    v1 -= ((v0 << 4) + key[2]) ^ (v0 + sum) ^ ((v0 >> 5) + key[3]);
    v0 -= ((v1 << 4) + key[0]) ^ (v1 + sum) ^ ((v1 >> 5) + key[1]);
    sum -= delta;
  }
  v[0] = v0;
  v[1] = v1;
}

int main() {
    uint32_t v5[4];
    uint32_t v6[11];
  v5[0] = 289739801;
  v5[1] = 427884820;
  v5[2] = 1363251608;
  v5[3] = 269567252;
  v6[0] = 2026214571;
  v6[1] = 578894681;
  v6[2] = 1193947460;
  v6[3] = -229306230;
  v6[4] = 73202484;
  v6[5] = 961145356;
  v6[6] = -881456792;
  v6[7] = 358205817;
  v6[8] = -554069347;
  v6[9] = 119347883;
  v6[10] = 0;
    for (int i = 0; i < 5; ++i) {
        TEA_decrypt(v6+i*2, v5);
        for (int j = 0; j < 8; ++j) {
            cout << (char)((uint8_t*)(v6+i*2))[j];
        }
    }
    
  return 0;
}
```

**moectf{h3r3_4_cuP_0f_734_f0R_y0U!!!!!!}**



# 09 ezpy

.pyc文件，用**uncompyle6** 转成.py文件；

`uncompyle6-o C:\Users\sjx\Desktop\ctf\moectf2025 "C:\Users\sjx\Desktop\ctf\moectf2025\ezpy (1).pyc"`

看到是对密文逐字节进行字母序的偏移

![image-20251218114855868](./image-20251218114855868.png)

解密就解除偏移，把加号改成减号即可；

```py
def caesar_cipher_encrypt(text, shift):

  result = []

  for char in text:

​    if char.isalpha():

​      if char.islower():

​        new_char = chr((ord(char) - ord("a") - shift) % 26 + ord("a"))

​      else:

​        if char.isupper():

​          new_char = chr((ord(char) - ord("A") - shift) % 26 + ord("A"))

​      result.append(new_char)

​    else:

​      result.append(char)

  else:

​    return "".join(result)

user_input = input("please input your flag：")

plaintext = user_input

shift = 114514

encrypted_text = caesar_cipher_encrypt(plaintext, shift)

print(encrypted_text)
```

**moectf{Y0u_Kn0W_pyc}**



# 10 ezwindow

winmain 函数中找到回调函数；

![image-20251218152957559](./image-20251218152957559.png)

结合窗口程序找到验证函数；

![image-20251218153352966](./image-20251218153352966.png)

前面有对v18的输出，结合后面对v18赋不同值，得v18为输出文字，操作v18的即为验证逻辑

![image-20251218155359764](./image-20251218155359764.png)

v18是赋值，n32是输入长度则一定为16，则v17一定为假；

![image-20251218155653459](./image-20251218155653459.png)

rust太乱了动调看看；发现就是简单异或0x2A

结合可知这个byte应该是密文；![image-20251218163701267](./image-20251218163701267.png)

解密；

```cpp
#include <iostream>
#include <cstdint>

int main() {
unsigned char IDA_7ff75e7e33b8[] = {0x47, 0x0, 0x45, 0x0, 0x4F, 0x0, 0x49, 0x0, 0x5E, 0x0, 0x4C, 0x0, 0x51, 0x0, 0x62, 0x0, 0x6A, 0x0, 0x5C, 0x0, 0x1E, 0x0, 0x75, 0x0, 0x4C, 0x0, 0x7F, 0x0, 0x44, 0x0, 0x57};
    for (size_t i = 0; i < sizeof(IDA_7ff75e7e33b8); i += 2) {
        std::cout << static_cast<char>(IDA_7ff75e7e33b8[i] ^ 0x2a);
    }
    return 0;
}
```

**moectf{H@v4_fUn}**



# 11 maze

走迷宫；

![image-20251218170919605](./image-20251218170919605.png)

`v4/n32/n0x37_1`是纵坐标，`v6/n0x37`是横坐标。

![image-20251218171101020](./image-20251218171101020.png)

从（1，1）开始，不能走到55x55（0x37）的外面；（15，32）是终点。

最后输出flag内容即为正确输入路径；

![image-20251218171219588](./image-20251218171219588.png)

dump出迷宫，并按上修改，终点用x标出；

```cpp
 #include <iostream>
#include <string>   
int main() {
   std::string v9[56];
 
   v9[0] = "11111111111111111111111111111111111111111111111111111111";
   v9[1] = "10100000000000000010000011011101011111111101011100000111";
   v9[2] = "10111010111111111010111011000001000001000001000101110111";
   v9[3] = "10000010000010000010001011011111111101110111011101110111";
   v9[4] = "10111111111011101110111011010000000000010100010001110111";
   v9[5] = "10100000001000101000100011010101111111011101110101110111";
   v9[6] = "10101011111110111011101011010101000001000000010101110111";
   v9[7] = "10101010000010100000101011110101110101111101111111110111";
   v9[8] = "10111010111010101111101011100101000100000101000101110111";
   v9[9] = "10000010001010001000001011001111011111010101011101110111";
  v9[10] = "11111011101011111011111111101000100000101100101001110111";
  v9[11] = "10001010001000100010000010001010011000100010010011000001";
  v9[12] = "10111010111110101010111011011001011111010101011101011101";
  v9[13] = "10001010001000001010001011000101000100000101000101011101";
  v9[14] = "11101011101111111011101011110101110111111101110101011101";
  v9[15] = "10001000101000001010001011000100010100000101000101011101";
  v9[16] = "10111111101011101110111011011111110101110111011101011101";
  v9[17] = "10001000001000100000001011000100000100010000000101011001";
  v9[18] = "11101011111011111111101011110101111101111111110101011011";
  v9[19] = "10101000000010001000101011010100000001000100010101011011";
  v9[20] = "10101111111110101010101011010111111111010101010101011011";
  v9[21] = "10100000000000100010101011010000000000010001010101011011";
  v9[22] = "10111111111111111110111011011111111111111111011101011011";
  v9[23] = "10000000001111000000000011110111010000111100011111011011";
  v9[24] = "11101111100000011011011111111010110111011101100001011011";
  v9[25] = "11101111111111111011011111111101110111101101100001011011";
  v9[26] = "10001000111111000010000011111010110111011101100001011011";
  v9[27] = "10111010111111111010111011110111010000111101100001010011";
  v9[28] = "10000010000010000010001011111111111111111101100001010111";
  v9[29] = "10111111111011101110111011110001000110001101100001010001";
  v9[30] = "10100000001000101000100011110111011101111101100001011101";
  v9[31] = "10101011111110111011101011110001000101111101100001011101";
  v9[32] = "10101010000010100000101011111101011101111101100001011101";
  v9[33] = "10111010111010101111101011110001000110001101100001011101";
  v9[34] = "10000010001010101000001011111111111111111101100001011101";
  v9[35] = "11111011101011111011111110000000000000001101100001011101";
  v9[36] = "10001010001000100010000011111111111111111100110011011101";
  v9[37] = "10111010111110101010111010010000000011111110001111011101";
  v9[38] = "10001010001000001010001010110111000001111110100101011101";
  v9[39] = "11101011101111111011101000110011001111111100110111011101";
  v9[40] = "10001000101000001010001011111111111111111111110111010001";
  v9[41] = "10111111101011101110111010100001001100000000000011011011";
  v9[42] = "10001000001000100000001011111111111101011101111001011011";
  v9[43] = "10101011111011111111101011000000000001000100010111011011";
  v9[44] = "10101000000010001000101010010111111111111111111111011011";
  v9[45] = "10101111111110101010101010110111111111111111111101011011";
  v9[46] = "10100000000000100010101011100000000000000000000011011011";
  v9[47] = "10111111111111111110011011111111111111111111111011011011";
  v9[48] = "10000011111111111111000010000000000000000000000000011001";
  v9[49] = "11111011111111111111111111111111111111111111111111111101";
  v9[50] = "11111011100001100110110111000000000000000000000111111101";
  v9[51] = "11111011101111011010000111011111111111111111110111111101";
  v9[52] = "11111011100001000010110110000111111111111111110000000001";
  v9[53] = "11111011101111011010110111101111111111111111111111111111";
  v9[54] = "11110000000000011000110000000000000000000000000000000011";
  v9[55] = "11111111111111111111111111111111111111111111111111111111";
  for (int i = 0; i <= 55; ++i) {
      for (int j = 0; j <= 55; j++) {
            char c = v9[i][j];
            if(i == 15 && j == 32) 
            {
                printf("X");
                continue;
            }
          if (c == '1') {
              std::cout << '#';
          } else {
              std::cout << '.';
          }
      }
      std::cout << std::endl;
   }
   return 0;
}
```

得到正确迷宫：

```
########################################################
#.#...............#.....##.###.#.#########.#.###.....###
#.###.#.#########.#.###.##.....#.....#.....#...#.###.###
#.....#.....#.....#...#.##.#########.###.###.###.###.###
#.#########.###.###.###.##.#...........#.#...#...###.###
#.#.......#...#.#...#...##.#.#.#######.###.###.#.###.###
#.#.#.#######.###.###.#.##.#.#.#.....#.......#.#.###.###
#.#.#.#.....#.#.....#.#.####.#.###.#.#####.#########.###
#.###.#.###.#.#.#####.#.###..#.#...#.....#.#...#.###.###
#.....#...#.#...#.....#.##..####.#####.#.#.#.###.###.###
#####.###.#.#####.#########.#...#.....#.##..#.#..###.###
#...#.#...#...#...#.....#...#.#..##...#...#..#..##.....#
#.###.#.#####.#.#.#.###.##.##..#.#####.#.#.#.###.#.###.#
#...#.#...#.....#.#...#.##...#.#...#.....#.#...#.#.###.#
###.#.###.#######.###.#.####.#.###.#######.###.#.#.###.#
#...#...#.#.....#.#...#.##...#..X#.#.....#.#...#.#.###.#
#.#######.#.###.###.###.##.#######.#.###.###.###.#.###.#
#...#.....#...#.......#.##...#.....#...#.......#.#.##..#
###.#.#####.#########.#.####.#.#####.#########.#.#.##.##
#.#.#.......#...#...#.#.##.#.#.......#...#...#.#.#.##.##
#.#.#########.#.#.#.#.#.##.#.#########.#.#.#.#.#.#.##.##
#.#...........#...#.#.#.##.#...........#...#.#.#.#.##.##
#.#################.###.##.#################.###.#.##.##
#.........####..........####.###.#....####...#####.##.##
###.#####......##.##.########.#.##.###.###.##....#.##.##
###.#############.##.#########.###.####.##.##....#.##.##
#...#...######....#.....#####.#.##.###.###.##....#.##.##
#.###.#.#########.#.###.####.###.#....####.##....#.#..##
#.....#.....#.....#...#.##################.##....#.#.###
#.#########.###.###.###.####...#...##...##.##....#.#...#
#.#.......#...#.#...#...####.###.###.#####.##....#.###.#
#.#.#.#######.###.###.#.####...#...#.#####.##....#.###.#
#.#.#.#.....#.#.....#.#.######.#.###.#####.##....#.###.#
#.###.#.###.#.#.#####.#.####...#...##...##.##....#.###.#
#.....#...#.#.#.#.....#.##################.##....#.###.#
#####.###.#.#####.#######...............##.##....#.###.#
#...#.#...#...#...#.....##################..##..##.###.#
#.###.#.#####.#.#.#.###.#..#........#######...####.###.#
#...#.#...#.....#.#...#.#.##.###.....######.#..#.#.###.#
###.#.###.#######.###.#...##..##..########..##.###.###.#
#...#...#.#.....#.#...#.######################.###.#...#
#.#######.#.###.###.###.#.#....#..##............##.##.##
#...#.....#...#.......#.############.#.###.####..#.##.##
#.#.#.#####.#########.#.##...........#...#...#.###.##.##
#.#.#.......#...#...#.#.#..#.#####################.##.##
#.#.#########.#.#.#.#.#.#.##.###################.#.##.##
#.#...........#...#.#.#.###.....................##.##.##
#.#################..##.#######################.##.##.##
#.....##############....#..........................##..#
#####.################################################.#
#####.###....##..##.##.###.....................#######.#
#####.###.####.##.#....###.###################.#######.#
#####.###....#....#.##.##....#################.........#
#####.###.####.##.#.##.####.############################
####...........##...##................................##
########################################################
```

BFS走迷宫

```c
#include <stdio.h>
#include <string.h>

#define MAX_ROWS 100
#define MAX_COLS 100

// 方向：WASD
int dx[4] = {-1, 0, 1, 0};  // 对应WSAD
int dy[4] = {0, -1, 0, 1};
char dir_char[4] = {'W', 'A', 'S', 'D'};

// 队列
int qx[MAX_ROWS * MAX_COLS], qy[MAX_ROWS * MAX_COLS];
int front = 0, rear = 0;

void enqueue(int x, int y) {
    qx[rear] = x;
    qy[rear] = y;
    rear++;
}

void dequeue(int *x, int *y) {
    *x = qx[front];
    *y = qy[front];
    front++;
}

int is_empty() {
    return front == rear;
}

int main() {
    char maze[MAX_ROWS][MAX_COLS];
    int rows = 0;
    
    // 读取迷宫
    char line[MAX_COLS];
    while (fgets(line, sizeof(line), stdin)) {
        line[strcspn(line, "\n")] = '\0';
        if (strlen(line) == 0) break;
        strcpy(maze[rows++], line);
    }
    
    // 起点和终点
    int start_x = 1, start_y = 1;
    int end_x = -1, end_y = -1;
    
    // 找到终点
    for (int i = 0; i < rows; i++) {
        for (int j = 0; maze[i][j]; j++) {
            if (maze[i][j] == 'X') {
                end_x = i;
                end_y = j;
            }
        }
    }
    
    if (end_x == -1) {
        printf("No X found!\n");
        return 1;
    }
    
    // BFS数据结构
    int visited[MAX_ROWS][MAX_COLS] = {0};
    int parent_x[MAX_ROWS][MAX_COLS];
    int parent_y[MAX_ROWS][MAX_COLS];
    char move_to[MAX_ROWS][MAX_COLS];  // 记录从父节点到这个节点的移动
    
    // 初始化
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < MAX_COLS; j++) {
            parent_x[i][j] = -1;
            parent_y[i][j] = -1;
            move_to[i][j] = ' ';
        }
    }
    
    // BFS开始
    enqueue(start_x, start_y);
    visited[start_x][start_y] = 1;
    parent_x[start_x][start_y] = start_x;  // 起点的父节点是自己
    parent_y[start_x][start_y] = start_y;
    
    int found = 0;
    
    while (!is_empty() && !found) {
        int x, y;
        dequeue(&x, &y);
        
        // 尝试四个方向
        for (int i = 0; i < 4; i++) {
            int nx = x + dx[i];
            int ny = y + dy[i];
            
            // 检查边界
            if (nx < 0 || nx >= rows || ny < 0 || ny >= strlen(maze[nx])) 
                continue;
            
            // 检查是否可通行且未访问
            if (!visited[nx][ny] && maze[nx][ny] != '#') {
                visited[nx][ny] = 1;
                parent_x[nx][ny] = x;
                parent_y[nx][ny] = y;
                move_to[nx][ny] = dir_char[i];  // 记录移动方向
                
                enqueue(nx, ny);
                
                // 检查是否是终点
                if (maze[nx][ny] == 'X') {
                    end_x = nx;
                    end_y = ny;
                    found = 1;
                    break;
                }
            }
        }
    }
    
    if (!found) {
        printf("No path found!\n");
        return 1;
    }
    
    // 回溯路径
    char path[10000];
    int path_len = 0;
    int cx = end_x, cy = end_y;
    
    // 从终点回溯到起点（不包括起点）
    while (!(cx == start_x && cy == start_y)) {
        // 获取到这个节点的移动方向
        char move = move_to[cx][cy];
        if (move != ' ') {
            path[path_len++] = move;
        }
        
        // 移动到父节点
        int px = parent_x[cx][cy];
        int py = parent_y[cx][cy];
        
        // 安全检查
        if (px == -1 || py == -1) {
            printf("Path backtracking error!\n");
            break;
        }
        
        cx = px;
        cy = py;
    }
    
    // 反转路径（因为是从终点回溯的）
    for (int i = 0; i < path_len / 2; i++) {
        char temp = path[i];
        path[i] = path[path_len - 1 - i];
        path[path_len - 1 - i] = temp;
    }
    
    path[path_len] = '\0';
    printf("%s\n", path);
    
    return 0;
}
```

**moectf{SSDDDDWWDDSSDDDDSSDDSSSSDDWWDDWWDDWWWWDDDDSSSSAASSSSAAAASSAASSAAWWAAWWWWAAAASSDDSSAASSDDSSSSAAAASSDDDDDDWWWWDDDDSSDDDDWWDDWWAAWWDDDDSSSSSSSSSSSSAAASSSDDDSSSSAASSSSAAAASSAASSAAWWAAWWWWAAAASSDDSSAASSDDSSSSAAAASSDDDDDDWWWWDDDDSSDDDDWWDDWWAAWWDDDDSSSSSSSSSSSSAAAWAWWWAASSAAWWAASSAAAAAAAAAAWWWWAASSSSSSDDDDSSSSSSDDDDDDDDDWWDDDSSDDWWWDDDSSSDDDDDWWAWWDDDDDDDDDDDDDDDDDDDDSSDDDDDDDDWWWWAWWWWWWWWDWWWWWWWWWWWAAWWDWWWWWWWWWWDWWWWWWAAAASSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSAAAWWAAAAAAAAAAAAAAAAAAAWWWDDDDDDDDWWDDDDDDDDDDWWWAWAAWAWWWWWWWWWWWWWDDWWWWAASSAAWWAASSAAAAAAAAAAWWWWAAWWDDWWAAWWDWWWDWWWWDDDDDDDDDDSSDDDDSSSSDSDSSDDSSAASSAAAAWWAAAASSSSAAAAAAWWDDDDWWWWAAWWAWAASSDSSSDD}**

# 12 upx_revenge

题目叫upx，但是DIE查不出壳，甚至文件都运行不了，ida打开也是明显加了壳的；

![image-20251219163033215](./image-20251219163033215.png)

猜测魔改了UPX头，010打开；

![image-20251219171926926](./image-20251219171926926.png)

版本号4.24后面没有`UPX!`标识，补一下;

就可以了；

`upx -d`脱壳；

![image-20251219172829120](./image-20251219172829120.png)

疑似base64，现在要找到表；

分析可知84行函数处理表（block），85行函数进行加密；

![image-20251219173637445](./image-20251219173637445.png)

加密是base64，现在要找到表；

![image-20251219173641379](./image-20251219173641379.png)

这个处理表的函数中第25行的异或很奇怪；

`i_1`是指向`block`的首字节的指针，推测`block`肯定很重要；

![image-20251219204258859](./image-20251219204258859.png)

点进`block`；

![image-20251219204734845](./image-20251219204734845.png)

**猜测`block`应该是指针**；按d转一下类型

![image-20251219204947851](./image-20251219204947851.png)

![image-20251219204925397](./image-20251219204925397.png)

发现表了，对表`^0xe`即得真表；

解出来不对？ 但前面几字节出了；

![image-20251219205200041](./image-20251219205200041.png)

**原来是字符串转义`\`需要输入`\\`!!!!**

*一开始连输出前面一点flag出了都没发现，一直以为还有加密，卡了将近2小时，已问候出题人*

删了多的`\`即可；

![image-20251219210203954](./image-20251219210203954.png)

**moectf{Y0u_Re4l1y_G00d_4t_Upx!!!}**



# 13 guess

main函数不能F5反编译；

![image-20251224230920263](./image-20251224230920263.png)

重定义main后下面标红，发现有很明显的花；

![image-20251224231357073](./image-20251224231357073.png)

上面跳转100%执行一个，则下面`call`一定不会执行，`nop`掉；

就能反编译了；

猜数字，猜对给flag；

![image-20251224231613118](./image-20251224231613118.png)

57行的判断逻辑改反就可以了；

`jnz`改`jz`；

![image-20251224231759297](./image-20251224231759297.png)

即可断出flag；

![image-20251224231932135](./image-20251224231932135.png)

**moectf{RrRRccCc44$$_w1th_fl0w3r!!_3c6a11b5}**



# 14 A simple program

似乎很简单一个`strcmp`；

![image-20251224232438002](./image-20251224232438002.png)

调试被反调断住了，开.exe判断是假flag；

![image-20251224232631687](./image-20251224232631687.png)

断的地方上面有个类似hook的函数，进去看看；

![image-20251224232836433](./image-20251224232836433.png)

发现下面的`dword`是`strncmp`的原型，hook成了`AB1510`函数；

![image-20251224233246830](./image-20251224233246830.png)

换成了异或比较；

![image-20251224233631013](./image-20251224233631013.png)

**moectf{Y0u_P4ssEd!!}**

# 15 Two cups of tea

xtea加密密钥`n2`,传入xxtea加密密文`v14`；

![image-20251225171141701](./image-20251225171141701.png)

![image-20251225171536590](./image-20251225171536590.png)

##### ![image-20251225171608218](./image-20251225171608218.png)

密钥直接打断点获取；

![image-20251225171755666](./image-20251225171755666.png)

```c++
void xxtea_decrypt(uint32_t* v, size_t n, const uint32_t* k) {
    const uint32_t DELTA = 1640531527;
    uint32_t rounds = 11;
    uint32_t sum = -rounds * DELTA;
    uint32_t y, z;

    y = v[0];
    while (rounds--) {
        uint32_t e = (sum >> 2) & 3;
        for (unsigned p = (unsigned)n - 1; p > 0; --p) {
            z = v[p - 1];
            y = v[p] -= (((z >> 5) ^ (y << 2)) + ((y >> 3) ^ (z << 4)))
                         ^ ((sum ^ y) + (k[(p & 3) ^ e] ^ z));
        }
        z = v[n - 1];
        y = v[0] -= (((z >> 5) ^ (y << 2)) + ((y >> 3) ^ (z << 4)))
                     ^ ((sum ^ y) + (k[(0 & 3) ^ e] ^ z));
        sum += DELTA;
    }
}


int main() {
uint32_t v14[10] = {0
};

v14[0] = 1566723124;
v14[1] = -2044068179;
v14[2] = -1659816037;
v14[3] = -53136879;
  v14[4] = 1175413710;
  v14[5] = -981373336;
  v14[6] = -28114771;
  v14[7] = 167777774;
  v14[8] = -1744380997;
  v14[9] = -280353208;
uint32_t key[4] = {0x63656F6D,0x21216674,0x12345678,0x9ABCDEF0};

xxtea_decrypt(v14, 10, (uint32_t*)key);

for (int i = 0; i < sizeof(v14)/sizeof(v14[0])*4; ++i) {
    printf("%c", *(uint8_t*)((uint8_t*)v14 + i));
}
    printf("\n");
}
```

改了DELTA,累加改成了累减；

**moectf{X7e4_And_xx7EA_I5_BeautifuL!!!!!}**

# 16 Ezandroidpro 

`check`函数检验在native层

![image-20251225122615673](./image-20251225122615673.png)

导出native层用ida分析；

![image-20251225123450544](./image-20251225123450544.png)

提示sm4，直接cyberchef试试；

![image-20251225123521606](./image-20251225123521606.png)

**moectf{SM4_Android_I5_Funing!!!}**

# 17 rusty_sudoku

数独，提示先要找到数独表；

![image-20251225124150256](./image-20251225124150256.png)

主程序中最后位掩码判断数独成功条件，

![image-20251225152844489](./image-20251225152844489.png)

![image-20251225152850125](./image-20251225152850125.png)

成功就转md5输出；

![image-20251225152939431](./image-20251225152939431.png)

所以只能正向做解数独；

查找字符串找到数独表；

![image-20251225153048491](./image-20251225153048491.png)

解数独

```c++
#include <stdio.h>
#include <stdbool.h>

#define N 9

// 打印网格
void printGrid(int grid[N][N]) {
    for (int row = 0; row < N; row++) {
        for (int col = 0; col < N; col++)
            printf("%d", grid[row][col]);
    }
}

// 检查是否可以将 num 放置在 grid[row][col]
bool isSafe(int grid[N][N], int row, int col, int num) {
    // 检查行
    for (int x = 0; x < N; x++)
        if (grid[row][x] == num)
            return false;

    // 检查列
    for (int x = 0; x < N; x++)
        if (grid[x][col] == num)
            return false;

    // 检查 3x3 子网格
    int startRow = row - row % 3, startCol = col - col % 3;
    for (int i = 0; i < 3; i++)
        for (int j = 0; j < 3; j++)
            if (grid[i + startRow][j + startCol] == num)
                return false;

    return true;
}

// 求解数独
bool solveSudoku(int grid[N][N], int row, int col) {
    // 如果到达第 8 行和第 9 列，则成功
    if (row == N - 1 && col == N)
        return true;

    // 如果列值变为 9，则移动到下一行
    if (col == N) {
        row++;
        col = 0;
    }

    // 如果当前位置已经有数字，则移动到下一列
    if (grid[row][col] > 0)
        return solveSudoku(grid, row, col + 1);

    for (int num = 1; num <= N; num++) {
        if (isSafe(grid, row, col, num)) {
            grid[row][col] = num;

            if (solveSudoku(grid, row, col + 1))
                return true;
        }
        grid[row][col] = 0;
    }
    return false;
}

int main() {
    char input[] = ".6..8..7.18.3......7.9....1...8...15.9..4.2..54...2..9.....3948.....5..7..3....5.";
    int grid[N][N];
    int k = 0;

    // 解析输入字符串
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            if (input[k] == '.') {
                grid[i][j] = 0;
            } else {
                grid[i][j] = input[k] - '0';
            }
            k++;
        }
    }

    printf("Original Sudoku:\n");
    printGrid(grid);
    printf("\n");

    if (solveSudoku(grid, 0, 0)) {
        printf("Solved Sudoku:\n");
        printGrid(grid);
    } else {
        printf("No solution exists");
    }

    return 0;
}

```

`369184572185327694274956831632879415897541263541632789756213948918465327423798156`

转一下md5；

**moectf{a8c79927d4e830c3fe52e79f410216a0}**
