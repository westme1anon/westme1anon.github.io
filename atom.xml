<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>wes1</title>
  <subtitle>ctfer</subtitle>
  <link href="https://www.wes1.cn/" rel="alternate" type="text/html"/>
  <link href="https://www.wes1.cn/atom.xml" rel="self" type="application/atom+xml"/>
  <id>https://www.wes1.cn/</id>
  <updated>2025-11-23T08:15:18.083Z</updated>
  <language>en</language>
  <entry>
    <title>逆向作业#4</title>
    <link href="https://www.wes1.cn/posts/%E9%80%86%E5%90%91%E4%BD%9C%E4%B8%9A4/" rel="alternate" type="text/html"/>
    <id>https://www.wes1.cn/posts/%E9%80%86%E5%90%91%E4%BD%9C%E4%B8%9A4/</id>
    <published>2025-11-20T00:00:00.000Z</published>
    <updated>2025-11-20T00:00:00.000Z</updated>
    <summary>校队逆向作业#4：花指令与壳</summary>
    <content type="html"><![CDATA[<h2>一道非常简单的去花</h2>
<p>打开ida发现标红；</p>
<p>4010d4jmp的地址错误，而上面很明显是花指令标志；</p>
<p><img src="https://www.wes1.cn/_astro/image-20251120152546747.DVKc3cYc_1Xby2p.webp" alt="image-20251120152546747" /></p>
<p><code>jz</code>和<code>jnz</code>互补，必有一个执行，所以4010D4的字节一定不会被执行，nop掉这个字节即可；</p>
<p>然后再对函数头<code>_main</code>按U再按P重定义；</p>
<p>就能正常按F5反编译了；</p>
<p><img src="https://www.wes1.cn/_astro/image-20251120153231761.BiEK6wxV_2k3UM7.webp" alt="image-20251120153231761" /></p>
<p>分析加密，可以看到是先对字符串每两字节交换位置，再逐字节异或0x30，再与密文比较；</p>
<p>解密：先用cyberchef对密文异或0x30，再复制代码换位即可；</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;cstdint&gt;
using namespace std;

string t="SNCSFTJ{su_tujknB_tyse}s";

int main()
{
    for (int  i = 0; i &lt; t.size() / 2; ++i )
  {
    char v5 = t[2 * i];
    t[2 * i] = t[2 * i + 1];
    t[2 * i + 1] = v5;
  }
  cout&lt;&lt;t;
}
</code></pre>
<p>NSSCTF{Just_junk_Bytess};</p>
<h2>一道非常简单的壳</h2>
<p>DIE查壳，64位程序，UPX壳；</p>
<p><img src="https://www.wes1.cn/_astro/image-20251121162552509.IvG_pnft_Z5gfVf.webp" alt="image-20251121162552509" /></p>
<h3>机脱</h3>
<p><code>sudo ./upx -d C:\Users\sjx\Desktop\ctf\例会作业\#4\作业\一道非常简单的壳\easyre.exe</code></p>
<p><img src="https://www.wes1.cn/_astro/image-20251121162931351.Bf6TEmqs_ZUzk86.webp" alt="image-20251121162931351" /></p>
<h3>手脱</h3>
<p>x64dbg打开，先寻找入口点；</p>
<p>追到pushad处，在push结束的栈顶下硬件断点，再按F9寻找popad；</p>
<p><img src="https://www.wes1.cn/_astro/image-20251122180133161.CvApANp5_Zay15l.webp" alt="image-20251122180133161" /></p>
<p><img src="https://www.wes1.cn/_astro/image-20251122193001304.BrQEkKr0_20jNPN.webp" alt="image-20251122193001304" /></p>
<p>硬件断点命中，明显jmp_401500是大跳转；</p>
<p><img src="https://www.wes1.cn/_astro/image-20251122193150294.Bt5VTHAs_2dvS0m.webp" alt="image-20251122193150294" /></p>
<p>F4过去，点进地址开始dump；</p>
<p><img src="https://www.wes1.cn/_astro/image-20251122193938807.fi1C8g3__Z1r00hU.webp" alt="image-20251122193938807" /></p>
<p>把标红的删了，rebuild PE,再fix dump；</p>
<p>拖入ida就能正常分析了；</p>
<p><img src="https://www.wes1.cn/_astro/image-20251122194438240.DrTqNtUl_13r3Ik.webp" alt="image-20251122194438240" /></p>
<h3>解密</h3>
<p>根本不让输入，那么查找字符串；</p>
<p>找到一个part2;</p>
<p><img alt="image-20251121172018182" /></p>
<p>左边函数表发现part1；</p>
<p><img alt="image-20251121172202975" /></p>
<p>像16进制，解一下得<code>XPU{galf</code></p>
<p>拼接得XPU{galfd_0n3_4nd_tw0}；</p>
<h2>N1CTF2020 - oflo</h2>
<p>打开ida发现标红；</p>
<p>400bb1的jmp很明显是花，分析发现执行到这里会直接jmp到+1位置，也就等效为不jmp，直接顺序运行，但跳过400bb1；</p>
<p>那么直接nop400bb1即可；</p>
<p><img alt="image-20251120153954571" /></p>
<p>在重定义一下，红变少了，应该对了；</p>
<p><img src="https://www.wes1.cn/_astro/image-20251122201820879.q6fzVG2J_Z28np7x.webp" alt="image-20251122201820879" /></p>
<p>400BB7的call后面有三字节未定义很奇怪，分析一下；</p>
<p>call进的400BBF中先把在栈顶的地址400BBC（call的下一条指令地址）推栈到外部rax，再对rax+1，再压栈，</p>
<p>则call返回的地址就偏移了一字节到400BBD，这个的地址直接jmp到400BD1;</p>
<p>那么<s>盲猜</s>先假定return前的都没用；就等价于nop掉call和其后面的一个字节；</p>
<p>红又少了，变成了一个jmp，又感觉对了；</p>
<p><img alt="image-20251120160348713" /></p>
<p>还有个一样的花，一样改掉；</p>
<p><img alt="image-20251120160436821" /></p>
<p>又出现一样的花，继续nop；</p>
<p><img alt="image-20251120160842302" /></p>
<p>再往下翻，注意到<code>call mprotect</code>,可能是要修改地址了，进附近函数分析一下；</p>
<p>修改后重定义即可f5反编译；</p>
<p><img src="https://www.wes1.cn/_astro/image-20251122205946698.DssrV_mL_ZT3GGi.webp" alt="image-20251122205946698" /></p>
<p>接下来太难了看wp了，不写了qwq；</p>
<ul>
<li>首先调用 <code>sub_4008B9()</code></li>
<li>接下来从输入读取 19 字节</li>
<li>调用 <code>mprotect()</code> 修改 <code>main &amp; 0xFFFFC000</code> 处权限为 <code>r | w | x</code>，由于权限控制粒度为内存页，因此这里实际上会修改一整张内存页的权限</li>
<li>修改 <code>sub_400A69()</code> 开头的 10 个字节</li>
<li>调用 <code>sub_400A69()</code> 检查 flag</li>
</ul>
]]></content>
    <author>
      <name>wes1meanon</name>
    </author>
    <category term="CTF"></category>
  </entry>
  <entry>
    <title>花指令</title>
    <link href="https://www.wes1.cn/posts/%E8%8A%B1%E6%8C%87%E4%BB%A4/" rel="alternate" type="text/html"/>
    <id>https://www.wes1.cn/posts/%E8%8A%B1%E6%8C%87%E4%BB%A4/</id>
    <published>2025-11-14T00:00:00.000Z</published>
    <updated>2025-11-14T00:00:00.000Z</updated>
    <summary>花指令总结，长期更新。</summary>
    <content type="html"><![CDATA[<h1>花指令总结</h1>
<h2><em>0x00 简介</em></h2>
<p><strong>花指令</strong><s>是区</s>是干扰反编译器正常分析的人为注入的垃圾指令，出题人通过插入一些垃圾（也可能会执行）汇编代码来让<strong>反编译器错误反编译</strong>，而<strong>不会干扰程序正常执行</strong>；</p>
<p><strong>修改花指令</strong>相当于<strong>修改（一般是简化）程序结构</strong>但<strong>不改变程序原有的执行逻辑</strong>（本来就是正确的，只是ida弄错了），**易于（即改成ida能分析正确的样子）**我们的ida爹反汇编正确。</p>
<h2>0x01   100%跳转到_地址+x</h2>
<p>特征：</p>
<ul>
<li>jz/jnz/jmp等跳转指令后接（<strong>函数地址+数字</strong>）</li>
<li>jz等条件跳转100%执行，或jz和jnz这种互补的条件跳转连着出现，即<strong>强制执行条件跳转</strong></li>
</ul>
<p>原理：</p>
<ul>
<li><strong>强制跳转的正常函数</strong>的字节码前面部被添上了垃圾字节，这个垃圾字节<strong>永远不会执行</strong></li>
<li>但反编译器不知道（地址+x）跳转是100%的，只会优先按正常执行顺序分析的字节*（原因可能是先执行等等）*</li>
<li>从而把垃圾指令当正常指令分析，把后面的东西全部带歪；</li>
</ul>
<p>解决办法：</p>
<ul>
<li>
<p>nop掉强制跳转的正常函数前面的垃圾字节，再重定义（对下面的标红的字节拖一下按c强转成code，再返回函数头按u再按p）即可；</p>
</li>
<li>
<p>对于一堆<strong>重复</strong>的这样的花指令，可以<strong>写py脚本批量处理</strong>：</p>
<pre><code>import idautils
import idc

def my_nop(addr, endaddr):  
    while addr &lt; endaddr:
        patch_byte(addr, 0x90)
        addr += 1

pattern = "E8 0A 00 00 00 E8 EB 0C 00 00 E8 F6 FF FF FF"   #重复花指令的字节串
cur_addr = 0x456000		#开始地址
end_addr = 0x467894		#结束地址

while cur_addr&lt;end_addr:
    cur_addr = idc.find_binary(cur_addr,SEARCH_DOWN,pattern)
    print("patch address: " + str(cur_addr)) # 打印提示信息
    if cur_addr == idc.BADADDR:
        break
    else:
        my_nop(cur_addr+5,cur_addr+6)  #想要nop的字节
        my_nop(cur_addr+8,cur_addr+14)  #想要nop的字节
    cur_addr = idc.next_head(cur_addr)
# from https://www.52pojie.cn/thread-1512089-1-1.html
</code></pre>
<p>or</p>
<pre><code>startaddr = 0x????
endaddr = 0x????

for i in range(startaddr,endaddr)
​	if get_wide_byte(i) == 0xEB
​		if get_wide_byte(i+1) == 0xFF #嵌套判断输出（加精度）
​			patch_byte(i,0x90)
​			print("[+] addr {} is patched".format(hex(i)) #格式化输出提示
</code></pre>
<blockquote>
<p>使用IDA自带的脚本编辑器：</p>
<p>IDA Pro提供了一个简单的脚本编辑器，可以用来编写和执行Python脚本：</p>
<ol>
<li>
<p><strong>打开脚本编辑器</strong></p>
<p>在IDA的菜单栏中，选择“File”-&gt;“Script file”选项。这将打开一个文件选择对话框，允许你选择一个Python脚本文件。</p>
</li>
<li>
<p><strong>执行脚本</strong></p>
<p>选择你要执行的Python脚本文件，然后点击“Open”按钮。IDA会自动加载并执行该脚本。</p>
</li>
</ol>
</blockquote>
</li>
</ul>
<p>举例：</p>
<ol>
<li>from 闻花识女人 <em>2025vn招新赛</em></li>
</ol>
<p><img src="https://www.wes1.cn/_astro/image-20251115200727288.DllqOR20_Z1XjDuN.webp" alt="image-20251115200727288" /></p>
<blockquote>
<p><code>test</code>命令将两个操作数进行逻辑与运算，并根据运算结果设置相关的标志位。但是，Test命令的两个操作数<strong>不会</strong>被改变。运算结果在设置过相关标记位后会被丢弃。</p>
<p><code>TEST AX,BX</code> 与<code>AND AX,BX</code>命令有相同效果，只是Test指令不改变AX和BX的内容，而AND指令会把结果保存到AX中。</p>
</blockquote>
<ul>
<li>
<p>rbx自身异或必然返回0，再test两个0必然也返回0，100%执行jz；</p>
</li>
<li>
<p>nop掉 2cc4的e9 或 jnz那一行，再重定义即可；</p>
</li>
</ul>
<ol>
<li>from bili:UKFC战队</li>
</ol>
<p><img src="https://www.wes1.cn/_astro/image-20251115203040563.CQLYA3Su_Z25IlWR.webp" alt="image-20251115203040563" /></p>
<ul>
<li>4188f9的jz和jnz互补，必有一个执行；</li>
<li>nop _18fd，其他同上；</li>
</ul>
<h2>0x02 废物call玩栈空间偏移return</h2>
<p>特征：</p>
<ul>
<li><code>call $+5</code></li>
<li>接着<em>唐突</em><code>pop xxx</code>+ 修改pop出的内容 +<code>push xxx</code></li>
<li><code>retn</code></li>
</ul>
<p>原理：</p>
<blockquote>
<p><strong>CALL指令的执行步骤</strong>：</p>
<ol>
<li><strong>保存返回地址</strong>：将当前指令的下一条指令地址（IP或CS:IP）压入栈中。</li>
<li><strong>跳转到目标地址</strong>：根据CALL指令的目标地址，修改IP或CS:IP寄存器的值。</li>
</ol>
</blockquote>
<blockquote>
<p>call的作用是将程序的执行流程跳转到指定的子程序地址，并在子程序执行完毕后通过<strong>RET指令</strong>返回到调用点继续执行。CALL指令与JMP指令类似，<strong>但增加了返回地址的保存功能</strong>。</p>
</blockquote>
<ul>
<li>
<p>call的字节码长度一般是5，<code>call $+5</code> (<em>我的理解</em> $相当与相对路径)等于什么也没执行，相当于顺序执行下去，<strong>除了将call指令的下一个地址压到了栈</strong>；</p>
<blockquote>
<p>push/call等入栈的东西会优先存储在栈顶，push弹栈也是先弹栈顶</p>
</blockquote>
</li>
<li>
<p>接着pop弹栈并将弹出的地址（即刚才call压栈的地址）存在一个寄存器里；</p>
</li>
<li>
<p>对这个寄存器进行修改；</p>
</li>
<li>
<p>push把修改后的寄存器压入栈；</p>
</li>
<li>
<p>return返回到修改后的地址；</p>
</li>
<li>
<p>这样就修改了call的return地址，但是ida默认call的返回地址不会被修改，这样就可以给<strong>垃圾指令</strong>留下空间，这些垃圾指令不会被执行但会被ida错误循序分析；</p>
</li>
</ul>
<p>修改方法：</p>
<ul>
<li>既然call是废物，那么把call和后面的一堆不执行的垃圾指令（到return的地址）全nop了就行，函数就会正确的顺序执行，也能正常分析</li>
</ul>
<p>举例：</p>
<p>1.from dirty_flower</p>
<p><img src="https://www.wes1.cn/_astro/image-20251115211807102.BGgjCrlw_ZuXhpy.webp" alt="image-20251115211807102" /></p>
<ul>
<li>分析如上，nop掉4012f2到401302即可；</li>
</ul>
<h2>0x03 重复计算</h2>
<p><img src="https://www.wes1.cn/_astro/image-20251109173230475.DlWQzuqM_Z1lTASA.webp" alt="image-20251115211504773" /></p>
]]></content>
    <author>
      <name>wes1meanon</name>
    </author>
    <category term="WIKI"></category>
  </entry>
  <entry>
    <title>z3求解器</title>
    <link href="https://www.wes1.cn/posts/z3/" rel="alternate" type="text/html"/>
    <id>https://www.wes1.cn/posts/z3/</id>
    <published>2025-11-14T00:00:00.000Z</published>
    <updated>2025-11-14T00:00:00.000Z</updated>
    <summary>z3的学习与使用</summary>
    <content type="html"><![CDATA[<h1>0x01 基本用法</h1>
<h2>求解器</h2>
<p>在使用 <code>z3</code> 进行约束求解之前我们首先需要获得一个 <em>求解器</em> 类实例，<strong>本质上其实就是一组约束的集合</strong>：</p>
<pre><code>&gt;&gt;&gt; s = z3.Solver()
</code></pre>
<h2>变量</h2>
<p>再创建用于解方程的变量</p>
<pre><code>import z3;
x = z3.Int(name = 'x')   #x是整形变量
y = z3.Real(name = 'y')   #y是实数
z = z3.BitVec(name= 'z', bv = 32)   #z是长度为32位的向量（向量长度需初始化）
p = z3.Bool(name = 'p')   #p是bool型
</code></pre>
<p>整型与实数类型变量之间可以互相进行转换：</p>
<pre><code>z3.ToReal(x)
z3.ToInt(y)
</code></pre>
<p>还能创建常量</p>
<pre><code>z3.IntVal(val = 114514) #int类型常量
</code></pre>
<h2>添加约束</h2>
<p>用add()方法为指定求解器添加约束，条件为初始化中变量组成的式子；</p>
<pre><code>s.add(x + 5 == 111)
s.add(y + 3 == x)
</code></pre>
<p>bool类型还可逻辑运算，暂且不表；</p>
<h2>约束求解</h2>
<p>使用check()方法寻找是否有解</p>
<pre><code>&gt;&gt;&gt; s.check()
sat  #有解
# 返回unsat则无解
</code></pre>
<p>若有解则可以通过model()方法获取一组解；</p>
<pre><code>&gt;&gt;&gt; if s.check() == z3.sat:
   		print(s.model())
[y = 103, x = 106]
</code></pre>
<h1>0x02 for CTF</h1>
<h2>初始化</h2>
<p>不用写z3.前缀；</p>
<pre><code>from z3 import *
</code></pre>
<p>用循环创建变量</p>
<pre><code>v = [Int(f'v{i}')    for i in range(0, 16)]  #f'{}'用来格式化字符串，传入后面的i
# or
x = [0] * 16
for i in range(16):
    x[i] = Int('x[' + str(i) + ']')
</code></pre>
<h2>求解</h2>
<p>model()方法会返回一个列表，比如</p>
<pre><code>[i11i1Iii1I1[14] = 49,
 i11i1Iii1I1[28] = 125,
 i11i1Iii1I1[27] = 51,
...
 i11i1Iii1I1[7] = 54]
</code></pre>
<p>接下来要做的是将解转化为字符，但由于该列表中的元素是z3中的特殊类型，需要先转换为python中的整数类型才能使用chr()函数转为对应字符;</p>
<p>但列表中解不是按未知参数或数组大小排序的，解决办法是循环访问列表中的值，将其作为索引去访问ans列表，即此处的【<strong>ans[i]</strong>】，然后使用as_long()函数将解的类型转为python中的int类型，最后使用chr()函数转为对应字符；</p>
<pre><code>if solver.check() == sat: #check()方法用来判断是否有解，sat(即satisify)表示满足有解
    ans = solver.model() #model()方法得到解
    for i in v:
        print(chr(ans[i].as_long()), end='')
#一般不会无解，如果无解八成是未知数变量的类型不符合，或约束方程添加错误
# or
if z3.Solver.check(s) == z3.sat: 
    ans = z3.Solver.model(s) 
    for i in i11i1Iii1I1:
        print(chr(ans[i].as_long()), end='')
</code></pre>
<h1>0x03 板子</h1>
<p><em>原文链接：https://blog.csdn.net/liKeQing1027520/article/details/138047537</em></p>
<p><em>板子作者：CSDN-晴友读钟</em></p>
<h2>预处理字符串</h2>
<pre><code>import re

def replace_func(match):
    shift = 2 #shift是指第一个未知数和0的差，例如：如果题目中第一个未知数是v2（如果是v3），那么shift就设置成2（就设置成3）
    index = int(match.group(1)) - shift
    return str(f'v[{index}]')  # 返回字符串'v[a后数字-1]'，用其替换匹配到的an

if __name__ == '__main__':
    s1 = ""  # 定义包含an的字符串
s1 = re.sub(r'v(2[0-9]|1[0-9]|[1-9])', replace_func, s1)
# sub函数参数, pattern、repl、string分别表示：正则表达式匹配规则、替换后结果（可以是函数也可以是常量）、要被查找替换的原始字符串
s1 = re.sub('!', '=', s1) #有些题目给的条件的方程是用'||'关系运算符连接的不等式方程，需要用这一行代码将'!'替换成'='变成等式方程
res = s1.split('| | ')
print(res)
</code></pre>
<p><strong>（ida）</strong> 将整串条件复制过来放进s1中之后，把多余的换行和空格删除掉*（shift+tab删除缩进）*，形成一连串的由关系运算符连接的条件；</p>
<p>接着你根据条件中具体的关系运算符，到底是"&amp;&amp;"还是"||"来使用split()函数将每个方程分隔开形成列表</p>
<p>在这里你需要仔细注意一下方程中的"||"中间有没有空格，如果有那你用的split()函数也得加上空格，即s1.split('| |')，因为你要让split()函数正确地找到分隔符</p>
<p>然后打印res就可以输出分割好的方程列表</p>
<h2>求解</h2>
<pre><code>from z3 import *

def solver_eng(fc):
    # 创建解释器对象
    solver = Solver()
    # 添加约束方程
    for i in range(len(fc)):
        solver.add(eval(fc[i])) #eval函数会将字符串形式的方程转换为z3模块能解析的方程
# 求解并转化为字符输出，得到flag

if solver.check() == sat:  # check()方法用来判断是否有解，sat(即satisify)表示满足有解
    ans = solver.model()  # model()方法得到解
    for i in v:
        print(chr(ans[i].as_long()), end='')
# 一般不会无解，如果无解八成是未知数变量的类型不符合，或约束方程添加错误
else:
    print("no ans!")
    
if __name__ == '__main__':
    # 设置方程，请用脚本将条件中的所有方程处理成列表，然后赋值给fc列表（这样你就不用一个一个方程慢慢去复制了）
    fc = []
    # 创建未知数变量
    v = [Int(f'v{i}') for i in range(0, len(fc))]
</code></pre>
<p>把这一整个列表复制下来，赋值给下面这个脚本的fc列表，直接运行就能出结果，这样脚本的通用性和便捷性大大提升了。</p>
]]></content>
    <author>
      <name>wes1meanon</name>
    </author>
    <category term="WIKI"></category>
  </entry>
  <entry>
    <title>逆向作业#3</title>
    <link href="https://www.wes1.cn/posts/%E9%80%86%E5%90%91%E4%BD%9C%E4%B8%9A3/" rel="alternate" type="text/html"/>
    <id>https://www.wes1.cn/posts/%E9%80%86%E5%90%91%E4%BD%9C%E4%B8%9A3/</id>
    <published>2025-11-11T00:00:00.000Z</published>
    <updated>2025-11-11T00:00:00.000Z</updated>
    <summary>校队逆向作业#3：多语言逆向</summary>
    <content type="html"><![CDATA[<h1>rustyapp</h1>
<p>shift+f12追一下显示的输入字符串，找到加密函数；</p>
<p><img src="https://www.wes1.cn/_astro/image-20251112175226672.D96zBPOt_2mrvaG.webp" alt="image-20251112175226672" /></p>
<p>对不明函数打断点动调一下，找一下逻辑，35行是打印，37行是输入并读取，v22存输入，下个硬件断点</p>
<p><img src="https://www.wes1.cn/_astro/image-20251113213759456.CLhrvsGm_Z1L0Peg.webp" alt="image-20251113213759456" /></p>
<p>最后比较是if（v2），v2==0就成功，对v2按x查找一下，有一个v2|=v15^0x21,那么v15都要xor0x21==0，即v15都是0x21，即输入的每一字符xor后面的字符串都要是0x21；</p>
<p>硬件断点一直不触发，应该只有一层加密；</p>
<p>根据异或的对称性即可直接解密；</p>
<p><img src="https://www.wes1.cn/_astro/image-20251113214348658.D1l0ABzr_Z1DISmw.webp" alt="image-20251113214348658" /></p>
<p><img src="https://www.wes1.cn/_astro/image-20251113215912245.BIfCTm5J_Z9hwDz.webp" alt="image-20251113215912245" /></p>
<p>STRU~MHCS@SX~BNSD~@RRDSU</p>
<h1>蛇年的本命语言</h1>
<p>先将封装的.exe文件用pyinstx转为.pyc，出现版本问题，换用-ng；</p>
<p><img src="https://www.wes1.cn/_astro/image-20251113223720376.xTnMHHMY_1lPFT3.webp" alt="image-20251113223720376" /></p>
<p>再用uncompyle6将.pyc转成.py;</p>
<p><img src="https://www.wes1.cn/_astro/image-20251113224322153.BByNemxX_Z1H374G.webp" alt="image-20251113224322153" /></p>
<p>修复一下.py,很明显的z3</p>
<p><img src="https://www.wes1.cn/_astro/image-20251114121121797.CnG9nUnP_Zl53S2.webp" alt="image-20251114121121797" /></p>
<p>写脚本解一下；</p>
<pre><code>import z3;
i11i1Iii1I1 = [0] * 30
for i in range(30):
  i11i1Iii1I1[i] = z3.Int(name = 'i11i1Iii1I1[' + str(i) + ']')
s = z3.Solver()
s.add(7 * i11i1Iii1I1[0] == 504,
​     9 * i11i1Iii1I1[0] - 5 * i11i1Iii1I1[1] == 403,
​     2 * i11i1Iii1I1[0] - 5 * i11i1Iii1I1[1] + 10 * i11i1Iii1I1[2] == 799,
​     3 * i11i1Iii1I1[0] + 8 * i11i1Iii1I1[1] + 15 * i11i1Iii1I1[2] + 20 * i11i1Iii1I1[3] == 2938,
​     5 * i11i1Iii1I1[0] + 15 * i11i1Iii1I1[1] + 20 * i11i1Iii1I1[2] - 19 * i11i1Iii1I1[3] + 1 * i11i1Iii1I1[4] == 2042,
​     7 * i11i1Iii1I1[0] + 1 * i11i1Iii1I1[1] + 9 * i11i1Iii1I1[2] - 11 * i11i1Iii1I1[3] + 2 * i11i1Iii1I1[4] + 5 * i11i1Iii1I1[5] == 1225,
​     11 * i11i1Iii1I1[0] + 22 * i11i1Iii1I1[1] + 33 * i11i1Iii1I1[2] + 44 * i11i1Iii1I1[3] + 55 * i11i1Iii1I1[4] + 66 * i11i1Iii1I1[5] - 77 * i11i1Iii1I1[6] == 7975,
​     21 * i11i1Iii1I1[0] + 23 * i11i1Iii1I1[1] + 3 * i11i1Iii1I1[2] + 24 * i11i1Iii1I1[3] - 55 * i11i1Iii1I1[4] + 6 * i11i1Iii1I1[5] - 7 * i11i1Iii1I1[6] + 15 * i11i1Iii1I1[7] == 229,
​     2 * i11i1Iii1I1[0] + 26 * i11i1Iii1I1[1] + 13 * i11i1Iii1I1[2] + 0 * i11i1Iii1I1[3] - 65 * i11i1Iii1I1[4] + 15 * i11i1Iii1I1[5] + 29 * i11i1Iii1I1[6] + 1 * i11i1Iii1I1[7] + 20 * i11i1Iii1I1[8] == 2107,
​     10 * i11i1Iii1I1[0] + 7 * i11i1Iii1I1[1] + -9 * i11i1Iii1I1[2] + 6 * i11i1Iii1I1[3] + 7 * i11i1Iii1I1[4] + 1 * i11i1Iii1I1[5] + 22 * i11i1Iii1I1[6] + 21 * i11i1Iii1I1[7] - 22 * i11i1Iii1I1[8] + 30 * i11i1Iii1I1[9] == 4037,
​     15 * i11i1Iii1I1[0] + 59 * i11i1Iii1I1[1] + 56 * i11i1Iii1I1[2] + 66 * i11i1Iii1I1[3] + 7 * i11i1Iii1I1[4] + 1 * i11i1Iii1I1[5] - 122 * i11i1Iii1I1[6] + 21 * i11i1Iii1I1[7] + 32 * i11i1Iii1I1[8] + 3 * i11i1Iii1I1[9] - 10 * i11i1Iii1I1[10] == 4950,
​     13 * i11i1Iii1I1[0] + 66 * i11i1Iii1I1[1] + 29 * i11i1Iii1I1[2] + 39 * i11i1Iii1I1[3] - 33 * i11i1Iii1I1[4] + 13 * i11i1Iii1I1[5] - 2 * i11i1Iii1I1[6] + 42 * i11i1Iii1I1[7] + 62 * i11i1Iii1I1[8] + 1 * i11i1Iii1I1[9] - 10 * i11i1Iii1I1[10] + 11 * i11i1Iii1I1[11] == 12544,
​     23 * i11i1Iii1I1[0] + 6 * i11i1Iii1I1[1] + 29 * i11i1Iii1I1[2] + 3 * i11i1Iii1I1[3] - 3 * i11i1Iii1I1[4] + 63 * i11i1Iii1I1[5] - 25 * i11i1Iii1I1[6] + 2 * i11i1Iii1I1[7] + 32 * i11i1Iii1I1[8] + 1 * i11i1Iii1I1[9] - 10 * i11i1Iii1I1[10] + 11 * i11i1Iii1I1[11] - 12 * i11i1Iii1I1[12] == 6585,
​     223 * i11i1Iii1I1[0] + 6 * i11i1Iii1I1[1] - 29 * i11i1Iii1I1[2] - 53 * i11i1Iii1I1[3] - 3 * i11i1Iii1I1[4] + 3 * i11i1Iii1I1[5] - 65 * i11i1Iii1I1[6] + 0 * i11i1Iii1I1[7] + 36 * i11i1Iii1I1[8] + 1 * i11i1Iii1I1[9] - 15 * i11i1Iii1I1[10] + 16 * i11i1Iii1I1[11] - 18 * i11i1Iii1I1[12] + 13 * i11i1Iii1I1[13] == 6893,
​     29 * i11i1Iii1I1[0] + 13 * i11i1Iii1I1[1] - 9 * i11i1Iii1I1[2] - 93 * i11i1Iii1I1[3] + 33 * i11i1Iii1I1[4] + 6 * i11i1Iii1I1[5] + 65 * i11i1Iii1I1[6] + 1 * i11i1Iii1I1[7] - 36 * i11i1Iii1I1[8] + 0 * i11i1Iii1I1[9] - 16 * i11i1Iii1I1[10] + 96 * i11i1Iii1I1[11] - 68 * i11i1Iii1I1[12] + 33 * i11i1Iii1I1[13] - 14 * i11i1Iii1I1[14] == 1883,
​     69 * i11i1Iii1I1[0] + 77 * i11i1Iii1I1[1] - 93 * i11i1Iii1I1[2] - 12 * i11i1Iii1I1[3] + 0 * i11i1Iii1I1[4] + 0 * i11i1Iii1I1[5] + 1 * i11i1Iii1I1[6] + 16 * i11i1Iii1I1[7] + 36 * i11i1Iii1I1[8] + 6 * i11i1Iii1I1[9] + 19 * i11i1Iii1I1[10] + 66 * i11i1Iii1I1[11] - 8 * i11i1Iii1I1[12] + 38 * i11i1Iii1I1[13] - 16 * i11i1Iii1I1[14] + 15 * i11i1Iii1I1[15] == 8257,
​     23 * i11i1Iii1I1[0] + 2 * i11i1Iii1I1[1] - 3 * i11i1Iii1I1[2] - 11 * i11i1Iii1I1[3] + 12 * i11i1Iii1I1[4] + 24 * i11i1Iii1I1[5] + 1 * i11i1Iii1I1[6] + 6 * i11i1Iii1I1[7] + 14 * i11i1Iii1I1[8] - 0 * i11i1Iii1I1[9] + 1 * i11i1Iii1I1[10] + 68 * i11i1Iii1I1[11] - 18 * i11i1Iii1I1[12] + 68 * i11i1Iii1I1[13] - 26 * i11i1Iii1I1[14] + 15 * i11i1Iii1I1[15] - 16 * i11i1Iii1I1[16] == 5847,
​     24 * i11i1Iii1I1[0] + 0 * i11i1Iii1I1[1] - 1 * i11i1Iii1I1[2] - 15 * i11i1Iii1I1[3] + 13 * i11i1Iii1I1[4] + 4 * i11i1Iii1I1[5] + 16 * i11i1Iii1I1[6] + 67 * i11i1Iii1I1[7] + 146 * i11i1Iii1I1[8] - 50 * i11i1Iii1I1[9] + 16 * i11i1Iii1I1[10] + 6 * i11i1Iii1I1[11] - 1 * i11i1Iii1I1[12] + 69 * i11i1Iii1I1[13] - 27 * i11i1Iii1I1[14] + 45 * i11i1Iii1I1[15] - 6 * i11i1Iii1I1[16] + 17 * i11i1Iii1I1[17] == 18257,
​     25 * i11i1Iii1I1[0] + 26 * i11i1Iii1I1[1] - 89 * i11i1Iii1I1[2] + 16 * i11i1Iii1I1[3] + 19 * i11i1Iii1I1[4] + 44 * i11i1Iii1I1[5] + 36 * i11i1Iii1I1[6] + 66 * i11i1Iii1I1[7] - 150 * i11i1Iii1I1[8] - 250 * i11i1Iii1I1[9] + 166 * i11i1Iii1I1[10] + 126 * i11i1Iii1I1[11] - 11 * i11i1Iii1I1[12] + 690 * i11i1Iii1I1[13] - 207 * i11i1Iii1I1[14] + 46 * i11i1Iii1I1[15] + 6 * i11i1Iii1I1[16] + 7 * i11i1Iii1I1[17] - 18 * i11i1Iii1I1[18] == 12591,
​     5 * i11i1Iii1I1[0] + 26 * i11i1Iii1I1[1] + 8 * i11i1Iii1I1[2] + 160 * i11i1Iii1I1[3] + 9 * i11i1Iii1I1[4] - 4 * i11i1Iii1I1[5] + 36 * i11i1Iii1I1[6] + 6 * i11i1Iii1I1[7] - 15 * i11i1Iii1I1[8] - 20 * i11i1Iii1I1[9] + 66 * i11i1Iii1I1[10] + 16 * i11i1Iii1I1[11] - 1 * i11i1Iii1I1[12] + 690 * i11i1Iii1I1[13] - 20 * i11i1Iii1I1[14] + 46 * i11i1Iii1I1[15] + 6 * i11i1Iii1I1[16] + 7 * i11i1Iii1I1[17] - 18 * i11i1Iii1I1[18] + 19 * i11i1Iii1I1[19] == 52041,
​     29 * i11i1Iii1I1[0] - 26 * i11i1Iii1I1[1] + 0 * i11i1Iii1I1[2] + 60 * i11i1Iii1I1[3] + 90 * i11i1Iii1I1[4] - 4 * i11i1Iii1I1[5] + 6 * i11i1Iii1I1[6] + 6 * i11i1Iii1I1[7] - 16 * i11i1Iii1I1[8] - 21 * i11i1Iii1I1[9] + 69 * i11i1Iii1I1[10] + 6 * i11i1Iii1I1[11] - 12 * i11i1Iii1I1[12] + 69 * i11i1Iii1I1[13] - 20 * i11i1Iii1I1[14] - 46 * i11i1Iii1I1[15] + 65 * i11i1Iii1I1[16] + 0 * i11i1Iii1I1[17] - 1 * i11i1Iii1I1[18] + 39 * i11i1Iii1I1[19] - 20 * i11i1Iii1I1[20] == 20253,
​     45 * i11i1Iii1I1[0] - 56 * i11i1Iii1I1[1] + 10 * i11i1Iii1I1[2] + 650 * i11i1Iii1I1[3] - 900 * i11i1Iii1I1[4] + 44 * i11i1Iii1I1[5] + 66 * i11i1Iii1I1[6] - 6 * i11i1Iii1I1[7] - 6 * i11i1Iii1I1[8] - 21 * i11i1Iii1I1[9] + 9 * i11i1Iii1I1[10] - 6 * i11i1Iii1I1[11] - 12 * i11i1Iii1I1[12] + 69 * i11i1Iii1I1[13] - 2 * i11i1Iii1I1[14] - 406 * i11i1Iii1I1[15] + 651 * i11i1Iii1I1[16] + 2 * i11i1Iii1I1[17] - 10 * i11i1Iii1I1[18] + 69 * i11i1Iii1I1[19] - 0 * i11i1Iii1I1[20] + 21 * i11i1Iii1I1[21] == 18768,
​     555 * i11i1Iii1I1[0] - 6666 * i11i1Iii1I1[1] + 70 * i11i1Iii1I1[2] + 510 * i11i1Iii1I1[3] - 90 * i11i1Iii1I1[4] + 499 * i11i1Iii1I1[5] + 66 * i11i1Iii1I1[6] - 66 * i11i1Iii1I1[7] - 610 * i11i1Iii1I1[8] - 221 * i11i1Iii1I1[9] + 9 * i11i1Iii1I1[10] - 23 * i11i1Iii1I1[11] - 102 * i11i1Iii1I1[12] + 6 * i11i1Iii1I1[13] + 2050 * i11i1Iii1I1[14] - 406 * i11i1Iii1I1[15] + 665 * i11i1Iii1I1[16] + 333 * i11i1Iii1I1[17] + 100 * i11i1Iii1I1[18] + 609 * i11i1Iii1I1[19] + 777 * i11i1Iii1I1[20] + 201 * i11i1Iii1I1[21] - 22 * i11i1Iii1I1[22] == 111844,
​     1 * i11i1Iii1I1[0] - 22 * i11i1Iii1I1[1] + 333 * i11i1Iii1I1[2] + 4444 * i11i1Iii1I1[3] - 5555 * i11i1Iii1I1[4] + 6666 * i11i1Iii1I1[5] - 666 * i11i1Iii1I1[6] + 676 * i11i1Iii1I1[7] - 660 * i11i1Iii1I1[8] - 22 * i11i1Iii1I1[9] + 9 * i11i1Iii1I1[10] - 73 * i11i1Iii1I1[11] - 107 * i11i1Iii1I1[12] + 6 * i11i1Iii1I1[13] + 250 * i11i1Iii1I1[14] - 6 * i11i1Iii1I1[15] + 65 * i11i1Iii1I1[16] + 39 * i11i1Iii1I1[17] + 10 * i11i1Iii1I1[18] + 69 * i11i1Iii1I1[19] + 777 * i11i1Iii1I1[20] + 201 * i11i1Iii1I1[21] - 2 * i11i1Iii1I1[22] + 23 * i11i1Iii1I1[23] == 159029,
​     520 * i11i1Iii1I1[0] - 222 * i11i1Iii1I1[1] + 333 * i11i1Iii1I1[2] + 4 * i11i1Iii1I1[3] - 56655 * i11i1Iii1I1[4] + 6666 * i11i1Iii1I1[5] + 666 * i11i1Iii1I1[6] + 66 * i11i1Iii1I1[7] - 60 * i11i1Iii1I1[8] - 220 * i11i1Iii1I1[9] + 99 * i11i1Iii1I1[10] + 73 * i11i1Iii1I1[11] + 1007 * i11i1Iii1I1[12] + 7777 * i11i1Iii1I1[13] + 2500 * i11i1Iii1I1[14] + 6666 * i11i1Iii1I1[15] + 605 * i11i1Iii1I1[16] + 390 * i11i1Iii1I1[17] + 100 * i11i1Iii1I1[18] + 609 * i11i1Iii1I1[19] + 99999 * i11i1Iii1I1[20] + 210 * i11i1Iii1I1[21] + 232 * i11i1Iii1I1[22] + 23 * i11i1Iii1I1[23] - 24 * i11i1Iii1I1[24] == 2762025,
​     1323 * i11i1Iii1I1[0] - 22 * i11i1Iii1I1[1] + 333 * i11i1Iii1I1[2] + 4 * i11i1Iii1I1[3] - 55 * i11i1Iii1I1[4] + 666 * i11i1Iii1I1[5] + 666 * i11i1Iii1I1[6] + 66 * i11i1Iii1I1[7] - 660 * i11i1Iii1I1[8] - 220 * i11i1Iii1I1[9] + 99 * i11i1Iii1I1[10] + 3 * i11i1Iii1I1[11] + 100 * i11i1Iii1I1[12] + 777 * i11i1Iii1I1[13] + 2500 * i11i1Iii1I1[14] + 6666 * i11i1Iii1I1[15] + 605 * i11i1Iii1I1[16] + 390 * i11i1Iii1I1[17] + 100 * i11i1Iii1I1[18] + 609 * i11i1Iii1I1[19] + 9999 * i11i1Iii1I1[20] + 210 * i11i1Iii1I1[21] + 232 * i11i1Iii1I1[22] + 23 * i11i1Iii1I1[23] - 24 * i11i1Iii1I1[24] + 25 * i11i1Iii1I1[25] == 1551621,
​     777 * i11i1Iii1I1[0] - 22 * i11i1Iii1I1[1] + 6969 * i11i1Iii1I1[2] + 4 * i11i1Iii1I1[3] - 55 * i11i1Iii1I1[4] + 666 * i11i1Iii1I1[5] - 6 * i11i1Iii1I1[6] + 96 * i11i1Iii1I1[7] - 60 * i11i1Iii1I1[8] - 220 * i11i1Iii1I1[9] + 99 * i11i1Iii1I1[10] + 3 * i11i1Iii1I1[11] + 100 * i11i1Iii1I1[12] + 777 * i11i1Iii1I1[13] + 250 * i11i1Iii1I1[14] + 666 * i11i1Iii1I1[15] + 65 * i11i1Iii1I1[16] + 90 * i11i1Iii1I1[17] + 100 * i11i1Iii1I1[18] + 609 * i11i1Iii1I1[19] + 999 * i11i1Iii1I1[20] + 21 * i11i1Iii1I1[21] + 232 * i11i1Iii1I1[22] + 23 * i11i1Iii1I1[23] - 24 * i11i1Iii1I1[24] + 25 * i11i1Iii1I1[25] - 26 * i11i1Iii1I1[26] == 948348,
​     97 * i11i1Iii1I1[0] - 22 * i11i1Iii1I1[1] + 6969 * i11i1Iii1I1[2] + 4 * i11i1Iii1I1[3] - 56 * i11i1Iii1I1[4] + 96 * i11i1Iii1I1[5] - 6 * i11i1Iii1I1[6] + 96 * i11i1Iii1I1[7] - 60 * i11i1Iii1I1[8] - 20 * i11i1Iii1I1[9] + 99 * i11i1Iii1I1[10] + 3 * i11i1Iii1I1[11] + 10 * i11i1Iii1I1[12] + 707 * i11i1Iii1I1[13] + 250 * i11i1Iii1I1[14] + 666 * i11i1Iii1I1[15] + -9 * i11i1Iii1I1[16] + 90 * i11i1Iii1I1[17] + -2 * i11i1Iii1I1[18] + 609 * i11i1Iii1I1[19] + 0 * i11i1Iii1I1[20] + 21 * i11i1Iii1I1[21] + 2 * i11i1Iii1I1[22] + 23 * i11i1Iii1I1[23] - 24 * i11i1Iii1I1[24] + 25 * i11i1Iii1I1[25] - 26 * i11i1Iii1I1[26] + 27 * i11i1Iii1I1[27] == 777044,
​     177 * i11i1Iii1I1[0] - 22 * i11i1Iii1I1[1] + 699 * i11i1Iii1I1[2] + 64 * i11i1Iii1I1[3] - 56 * i11i1Iii1I1[4] - 96 * i11i1Iii1I1[5] - 66 * i11i1Iii1I1[6] + 96 * i11i1Iii1I1[7] - 60 * i11i1Iii1I1[8] - 20 * i11i1Iii1I1[9] + 99 * i11i1Iii1I1[10] + 3 * i11i1Iii1I1[11] + 10 * i11i1Iii1I1[12] + 707 * i11i1Iii1I1[13] + 250 * i11i1Iii1I1[14] + 666 * i11i1Iii1I1[15] + -9 * i11i1Iii1I1[16] + 0 * i11i1Iii1I1[17] + -2 * i11i1Iii1I1[18] + 69 * i11i1Iii1I1[19] + 0 * i11i1Iii1I1[20] + 21 * i11i1Iii1I1[21] + 222 * i11i1Iii1I1[22] + 23 * i11i1Iii1I1[23] - 224 * i11i1Iii1I1[24] + 25 * i11i1Iii1I1[25] - 26 * i11i1Iii1I1[26] + 27 * i11i1Iii1I1[27] - 28 * i11i1Iii1I1[28] == 185016,
​     77 * i11i1Iii1I1[0] - 2 * i11i1Iii1I1[1] + 6 * i11i1Iii1I1[2] + 6 * i11i1Iii1I1[3] - 96 * i11i1Iii1I1[4] - 9 * i11i1Iii1I1[5] - 6 * i11i1Iii1I1[6] + 96 * i11i1Iii1I1[7] - 0 * i11i1Iii1I1[8] - 20 * i11i1Iii1I1[9] + 99 * i11i1Iii1I1[10] + 3 * i11i1Iii1I1[11] + 10 * i11i1Iii1I1[12] + 707 * i11i1Iii1I1[13] + 250 * i11i1Iii1I1[14] + 666 * i11i1Iii1I1[15] + -9 * i11i1Iii1I1[16] + 0 * i11i1Iii1I1[17] + -2 * i11i1Iii1I1[18] + 9 * i11i1Iii1I1[19] + 0 * i11i1Iii1I1[20] + 21 * i11i1Iii1I1[21] + 222 * i11i1Iii1I1[22] + 23 * i11i1Iii1I1[23] - 224 * i11i1Iii1I1[24] + 26 * i11i1Iii1I1[25] - -58 * i11i1Iii1I1[26] + 27 * i11i1Iii1I1[27] - 2 * i11i1Iii1I1[28] + 29 * i11i1Iii1I1[29] == 130106)

if z3.Solver.check(s) == z3.sat: 
  ans = z3.Solver.model(s) 
  for i in i11i1Iii1I1:
​    print(chr(ans[i].as_long()), end='') #按顺序输出
</code></pre>
<p>H1Z1N1U1C1T1F1{1a6d275f7-463}1</p>
<p>有点问题，回看一下加密代码，分析一下；</p>
<pre><code>from collections import Counter
print("Welcome to HZNUCTF!!!")
print("Plz input the flag:")
inp = input()
coutinp = Counter(inp)  #统计输入的字符串（flag）中每个字符出现的次数
O0o00 = "".join((str(coutinp[inpstr]) for inpstr in inp))  #将每个字符按在flag中出现的字数为掩码替换
print("ans1: ", end="")
print(O0o00)
iiIII = ""
if O0o00 != "111111116257645365477364777645752361":  #比较掩码
    print("wrong_wrong!!!")
    exit(1)
for inpstr in inp:
    if coutinp[inpstr] &gt; 0:
        iiIII += inpstr + str(coutinp[inpstr]) 
        coutinp[inpstr] = 0
#flag中每个重复的字符只输出第一次，并在后面加上重复次数
</code></pre>
<p>映射分析，H1Z1N1U1C1T1F1 {1 a6 d2 75 f7 -4 63 }1</p>
<p>​		  111111116257645365477364777645752361</p>
<p>第一个1对应H，第二个1对应Z，....,6都对应a......</p>
<p>手改一下，HZNUCTF{ad7fa-76a7-ff6a-fffa-7f7d6a}</p>
<h1>⽔果忍者</h1>
<p>dnspy打开Assembly-CSharp.dll文件</p>
<p>主类里翻到一个hint</p>
<pre><code>"Locate the 'FlagContainer' class in the Program Resource Manager",
"Submit in format: flag{xxxx}"
</code></pre>
<p>找一下FlagContainer，其中</p>
<pre><code>[EncodedFlag("D1ucj0u!tqjwf!fohjoffsjoh!xj!epspqz!ju!gvo!2025")]
</code></pre>
<p>再找到main函数</p>
<p>调用了一个decode()函数，得到的值传给text</p>
<p>猜测text中即为flag，直接下断点动调；<img src="https://www.wes1.cn/_astro/image-20251114215051524.CNYJhkGk_1r9X6E.webp" alt="image-20251114215051524" /></p>
<p>变量中直接看到flag内容，结合hint中的format，</p>
<p><img src="https://www.wes1.cn/_astro/image-20251114215310490.CVKIwW1i_ZwLxtD.webp" alt="image-20251114215344714" /></p>
<p>flag{D1tbi0t_spive_engineering_wi_doropy_it_fun_2025}（好像没有检验程序？）</p>
<h1>cccc</h1>
<p>dnspy打开.dll,明显被混淆</p>
<p><img src="https://www.wes1.cn/_astro/image-20251116130757247.BVVmYWEJ_ZOxUtS.webp" alt="image-20251116130757247" /></p>
<p>使用de4dot脱壳，重新打开</p>
<p><img src="https://www.wes1.cn/_astro/image-20251116131549791.BujtZoQa_ZJQdc2.webp" alt="image-20251116131549791" /></p>
<p>无法调试，发现这是32位程序，重新找一个32位的dnspy打开</p>
<p>也报错，最后发现要将-clean的文件重命名成原来的才能动调，非常奇怪；</p>
<p>函数太多了难以分析，先找到main函数一步步动调；</p>
<p><img src="https://www.wes1.cn/_astro/image-20251116133809476.D2Jb2Rmg_Yfnmv.webp" alt="image-20251116133809476" /></p>
<p>num中的值应该是密文；</p>
<p><img src="https://www.wes1.cn/_astro/image-20251116144536982.B3XuHlFn_2qH74o.webp" alt="image-20251116144536982" /></p>
<p>前面的一大坨应该是对输入进行utf等的处理，先不管；</p>
<p>然后找到一个可疑text："doyouknowcsharp"</p>
<p><img src="https://www.wes1.cn/_astro/image-20251116150828106.BHQBi_1b_Z1aqlwb.webp" alt="image-20251116150828106" /></p>
<p>然后找到一个rc4；</p>
<pre><code>T0[] array = GClass0.smethod_3&lt;T0, T1&gt;(GClass0.smethod_0&lt;T0, T1, T2&gt;(gparam_0));
		T1 t = 0;
		T1 t2 = 0;
		T0[] array2;   //输入
		for (;;)
		{
			IL_132:
			uint num = 965942686U;
			for (;;)
			{
				uint num2;
				switch ((num2 = (num ^ 1671582653U)) % 10U)
				{
				case 1U:
				{
					T1 t3 = 0;
					num = (num2 * 2964175099U ^ 3088226582U);
					continue;
				}
				case 2U:
					num = (num2 * 2557159329U ^ 3766832993U);
					continue;
				case 3U:
				{
					T0 t4;
					array[t2] = t4;
					num = (num2 * 1977227374U ^ 428192606U);
					continue;
				}
				case 4U:
				{
					T1 t3;
					num = ((t3 &gt;= gparam_1.Length) ? 135939119U : 530945064U);
					continue;
				}
				case 5U:
				{
					T1 t3;
					array2[t3] = (byte)(gparam_1[t3] ^ array[(array[t] + array[t2]) % 256] ^ 100);		//多异或了一个100
					num = (num2 * 1446099815U ^ 1371508486U);
					continue;
				}
				case 6U:
				{
					T1 t3;
					t3++;
					num = (num2 * 1047750269U ^ 2517980139U);
					continue;
				}
				case 7U:
					array2 = new T0[gparam_1.Length];
					num = (num2 * 835581391U ^ 1087374551U);
					continue;
				case 8U:
					goto IL_132;
				case 9U:
				{
					t = (t + 1) % 256;
					t2 = (array[t] + t2) % 256;
					T0 t4 = array[t];
					array[t] = array[t2];     //这里交换s盒很好分辨rc4
					num = 593623138U;
					continue;
				}
</code></pre>
<p>然后就没有能看懂的有意义的了，基本上全是输入输出字符串处理；</p>
<p>cyberchef试着解一下，对了；</p>
<p><img src="https://www.wes1.cn/_astro/image-20251116152559975.CY8jl3Ca_Z1spuro.webp" alt="image-20251116152559975" /></p>
<p>flag{y0u_r34lly_kn0w_m@ny_pr0gr@mm1ng_l@ngu@g3$}</p>
<h1><s>rust_baby</s></h1>
<h3>做蒙了才发现这个_baby原来不是简单一点的意思，加密也太多了，以后再来探索吧(</h3>
<p>ida打开，main函数看不清逻辑，字符串搜索也一无所获，尝试动调；</p>
<p>对每个不太能识别的函数下断点，试图定位输入函数；</p>
<p><img src="https://www.wes1.cn/_astro/image-20251112144750774.DDS7vmRM_1Y1Wnu.webp" alt="image-20251112144750774" /></p>
<p>断点命中172行，疑似是主逻辑，sub_298a中东西很多；</p>
<p><img src="https://www.wes1.cn/_astro/image-20251112145624829.7P7zgzx2_Z14Nj2x.webp" alt="image-20251112145624829" /></p>
<p>定位到函数中318行为print，319行为输入，351行为处理输入</p>
<p><img src="https://www.wes1.cn/_astro/image-20251112150603489.BqYxt-4t_1Uea6G.webp" alt="image-20251112150603489" /></p>
<p>栈空间和hexview中抓到了输入；8位一处理，不全补e，现在要看它转到了哪；</p>
<p>感觉是处理了之后存到v195_4里面了给这个打个硬件断点，断到了v185</p>
<p><img src="https://www.wes1.cn/_astro/image-20251112155735873.Cwwy7-VC_BMm2i.webp" alt="image-20251112155735873" /></p>
<p><img src="https://www.wes1.cn/_astro/image-20251112161457906.BkbKlFzg_Z33gDJ.webp" alt="image-20251112161457906" /></p>
<p>继续下断点，知893行即为判断逻辑，n32_5里的是密文，src是加密后的明文，逐位比较；</p>
<p><img src="https://www.wes1.cn/_astro/image-20251112174036255.COSmKqKq_ZYYfGc.webp" alt="image-20251112174036255" /></p>
]]></content>
    <author>
      <name>wes1meanon</name>
    </author>
    <category term="CTF"></category>
  </entry>
  <entry>
    <title>qctf-hachimi</title>
    <link href="https://www.wes1.cn/posts/qctf-hachimi/" rel="alternate" type="text/html"/>
    <id>https://www.wes1.cn/posts/qctf-hachimi/</id>
    <published>2025-11-09T00:00:00.000Z</published>
    <updated>2025-11-09T00:00:00.000Z</updated>
    <summary>浅看trycatch混淆</summary>
    <content type="html"><![CDATA[<h1>hachimi</h1>
<h2>0x01 去trycatch反调试</h2>
<p>ida打开发现很明显代码不完整，看到trylevel这个函数，搜索知是用于修改trycatch异常处理等级的函数，程序很可能是通过trycatch进行混淆；</p>
<p><img src="https://www.wes1.cn/_astro/image-20251109155425794.DqFCt-7r_Z1TOHdm.webp" alt="image-20251109155425794" /></p>
<p>看汇编，真正程序应该在except块里，</p>
<p><img src="https://www.wes1.cn/_astro/image-20251109161232841.DwLINL83_ZtWHhI.webp" alt="image-20251109161232841" /></p>
<p>正常逻辑如下进入4e1357</p>
<p><img src="https://www.wes1.cn/_astro/image-20251109161610905.BpVS3_tO_Z19ceXs.webp" alt="image-20251109161610905" /></p>
<p>其中注意到dir ecx，ecx是0，这里抛出除零异常进入expect块；</p>
<p><img src="https://www.wes1.cn/_astro/image-20251109161640762.TSjR7zA6_Z1FicE0.webp" alt="image-20251109161640762" /></p>
<p>流程如下：ida默认了jmp从而忽略了expect的反编译；</p>
<p>// ida不能识别异常，函数只有通过jge再到jmp一条路可走，认为上面_except这一块永远不会执行；</p>
<p><img src="https://www.wes1.cn/_astro/image-20251109171126516.BNJO3bVT_1mrv1s.webp" alt="image-20251109171126516" /></p>
<p>既然jmp_145e不会执行，那就把jmp_145e nop掉,后面还有个except过滤器也nop了；</p>
<p>代码就正常了；</p>
<p>// 这样让expect一定会顺序执行，因为他本来就一定会执行，所以正好是对的</p>
<p><img src="https://www.wes1.cn/_astro/image-20251109173030682.BNxdLv7o_MKboT.webp" alt="image-20251109173030682" /></p>
<h2>0x02 去花</h2>
<p><img src="https://www.wes1.cn/_astro/image-20251109173144206.DSueWVyh_1UOPV8.webp" alt="image-20251109173144206" /></p>
<p>加密代码不完整，继续看汇编；</p>
<p><img src="https://www.wes1.cn/_astro/image-20251109173230475.DlWQzuqM_Z1lTASA.webp" alt="image-20251109173230475" /></p>
<p>下面的call_+5和jz很明显是花，直接force jump,得到完整加密；</p>
<p><img src="https://www.wes1.cn/_astro/image-20251109182400912.aR3fb9qg_1BSXOR.webp" alt="image-20251109182400912" /></p>
<p>先tea后异或，解密如下：</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;stdint.h&gt;
using namespace std;

uint32_t v8[4]={};
uint8_t v9[32]={0x4D,0x7A,0x3E,0x7A,0x84,0xFF,0x51,0xB1,0x31,0x97,0xFB,0xDC,0x2B,0xA4,0xCD,0xFB,0x85,0xCD,0xA,0x2B,0xBD,0x91,0xCF,0x69,0xBA,0x2B,0x70,0xD5,0x43,0xB8,0x3E,0x1f};

 unsigned long byteswap_manual(unsigned long value)  //转大小端的函数
 {
 return ((value&gt;&gt;24) &amp; 0xFF) |
((value &gt;&gt; 8) &amp; 0xFF00) | 
((value &lt;&lt; 8) &amp; 0xFF0000) |
((value &lt;&lt; 24) &amp; 0xff0000);
 }


void tea_dec(uint32_t* a1, uint32_t* a2) {
  unsigned __int32 result; // eax
  unsigned int i; // [esp+8h] [ebp-14h]
  int j; // [esp+Ch] [ebp-10h]
  unsigned int v5 = 0; // [esp+10h] [ebp-Ch]
  unsigned int v6 = 0; // [esp+14h] [ebp-8h]
    for ( j = 0; j &lt; 8; ++j )
  {
    *((uint8_t *)a1 + j) ^= *(uint8_t *)(a2 + 15 - j);
  }
  *a1 = byteswap_manual(*a1);
  *(a1+1) = byteswap_manual(*(a1+1));
    uint32_t v0 = a1[0], v1 = a2[1];  // v0、v1分别是密文的左、右半部分
    uint32_t delta = 1640531527;     //作为sum每次累加的变化值，题目中往往会修改此值
    uint32_t v7 = 32 * (-delta);      //此处需要分析32轮加密结束后sum的值与delta的变化, 以此处加密为例子，32轮每次sum+=delta，因此最后sum=32*delta
    for (int i = 0; i &lt; 32; i++) {  // tea加密进行32轮
        //根据加密时的顺序颠倒下面3行的顺序，将加法改为减法（异或部分都是整体，不用管），就是逆向解密过程
    v5 -= (*(uint32_t *)(a2 + 4 * ((v7 &gt;&gt; 11) &amp; 3)) + v7) ^ (v6 + ((v6 &gt;&gt; 5) ^ (16 * v6)));
    v7 += 1640531527;
    v6 -= (*(uint32_t *)(a2 + 4 * (v7 &amp; 3)) + v7) ^ (v5 + ((v5 &gt;&gt; 5) ^ (16 * v5)));
    }
    // 因此解密后的内容要还给v数组
    *(uint32_t*)(v9+j) = v0;
    *(uint32_t*)(v9+j) = v1;
  return ;
}

int main()
{
  v8[0] = 1495531287;
  v8[1] = -1758678609;
  v8[2] = -880611118;
  v8[3] = -38157364;
  for(int j = 0;j &lt; 8;j+=2)
    tea_dec((uint32_t*)(v9+j),v8);
  for(char a:v9)
    cout&lt;&lt;a;
}
</code></pre>
<p>flag{ha_ha_hachimi_na_bei_lu_do};</p>
]]></content>
    <author>
      <name>wes1meanon</name>
    </author>
    <category term="CTF"></category>
  </entry>
  <entry>
    <title>qctf-fisher</title>
    <link href="https://www.wes1.cn/posts/qctf-fisher/" rel="alternate" type="text/html"/>
    <id>https://www.wes1.cn/posts/qctf-fisher/</id>
    <published>2025-11-06T00:00:00.000Z</published>
    <updated>2025-11-06T00:00:00.000Z</updated>
    <summary>inline hook分析</summary>
    <content type="html"><![CDATA[<h1>fisher</h1>
<h2>0x01 解密</h2>
<p>ida打开文件，main函数：</p>
<p><img src="https://www.wes1.cn/_astro/image-20251108183320408.DZpU6XJc_Z1plkQ9.webp" alt="image-20251108183320408" /></p>
<p>将输入加密为str1与密文比较，加密逻辑为换表base64；</p>
<p><img src="https://www.wes1.cn/_astro/image-20251108183552278.ChqiElF1_Z1k4WRf.webp" alt="image-20251108183552278" /></p>
<p>fake flag;</p>
<p>尝试动调也错，感觉strcmp不能正常执行；</p>
<p>动调进入strcmp，发现系统指令被修改为一个jmp，进入后出现真正的加密函数</p>
<p><img src="https://www.wes1.cn/_astro/image-20251108195116827.Db0yA-1x_1LrtGJ.webp" alt="image-20251108195116827" /></p>
<p>输入每八位执行一个tea加密（sub_7ff)，v5是密文，v9是key（后八位是0）；</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;print&gt;
#include&lt;stdint.h&gt;
using namespace std;

unsigned char v5[64]={};
unsigned char v9[16]={};

void tea_dec(uint32_t* v, uint32_t* k) {
    uint32_t v0 = v[0], v1 = v[1];  // v0、v1分别是密文的左、右半部分
    uint32_t delta = -1835914967;     //作为sum每次累加的变化值，题目中往往会修改此值
    uint32_t sum = 32 * delta;      //此处需要分析32轮加密结束后sum的值与delta的变化, 以此处加密为例子，32轮每次sum+=delta，因此最后sum=32*delta
    for (int i = 0; i &lt; 32; i++) {  // tea加密进行32轮
        //根据加密时的顺序颠倒下面3行的顺序，将加法改为减法（异或部分都是整体，不用管），就是逆向解密过程
        v1 -= ((v0 &lt;&lt; 4) + k[2]) ^ (v0 + sum) ^ ((v0 &gt;&gt; 5) + k[3]);
        v0 -= ((v1 &lt;&lt; 4) + k[0]) ^ (v1 + sum) ^ ((v1 &gt;&gt; 5) + k[1]);
        sum -= delta;
    }
    // 因此解密后的内容要还给v数组
    v[0] = v0;
    v[1] = v1;
}
 int main()
 {
  v5[0] = 8;
  v5[1] = -18;
  v5[2] = 89;
  v5[3] = 77;
  v5[4] = 13;
  v5[5] = -32;
  v5[6] = -64;
  v5[7] = -119;
  v5[8] = -95;
  v5[9] = -104;
  v5[10] = -78;
  v5[11] = -69;
  v5[12] = -49;
  v5[13] = 112;
  v5[14] = 127;
  v5[15] = -27;
  v5[16] = -24;
  v5[17] = 47;
  v5[18] = -102;
  v5[19] = -118;
  v5[20] = 32;
  v5[21] = -53;
  v5[22] = 116;
  v5[23] = 18;
  v5[24] = -14;
  v5[25] = 48;
  v5[26] = 120;
  v5[27] = 31;
  v5[28] = 14;
  v5[29] = -21;
  v5[30] = 31;
  v5[31] = -120;
  v5[32] = -56;
  v5[33] = -68;
  v5[34] = 78;
  v5[35] = -8;
  v5[36] = 82;
  v5[37] = 19;
  v5[38] = 83;
  v5[39] = -117;
  v5[40] = -99;
  v5[41] = -65;
  v5[42] = 102;
  v5[43] = 11;
  v5[44] = 106;
  v5[45] = -84;
  v5[46] = 33;
  v5[47] = 79;
  v5[48] = -23;
  v5[49] = 31;
  v5[50] = 70;
  v5[51] = 70;
  v5[52] = -98;
  v5[53] = -53;
  v5[54] = -6;
  v5[55] = 99;
  v5[56] = -93;
  v5[57] = -123;
  v5[58] = 20;
  v5[59] = -55;
  v5[60] = 46;
  v5[61] = -9;
  v5[62] = 16;
  v5[63] = -59;
  v9[0] = 17;
  v9[1] = 34;
  v9[2] = 51;
  v9[3] = 68;
  v9[4] = 85;
  v9[5] = 102;
  v9[6] = 119;
  v9[7] = -120;
  for (int i = 0;i &lt;= 7;i++)
  {
    tea_dec((uint32_t*)(v5+8*i), (uint32_t*)v9);
  }
  for (char a : v5)
  cout&lt;&lt;a;
 }
</code></pre>
<p>输出：zCN7zTJg0xnEzxjJywV50xn53CvO4vZPyxrF2SzFzwr53SBQ0fZV1TvOxSj70xrZ；</p>
<p>因为调用的是str1，所以还要base64回去，</p>
<p>flag{Fisherman_is_very_satisfied_with_your_bait}</p>
<h2>0x02 hook原理分析</h2>
<p>查看真实加密函数调用，找到这样的函数</p>
<p><img src="https://www.wes1.cn/_astro/image-20251108204603109.BTKuS6TD_1Fve08.webp" alt="image-20251108204603109" /></p>
<p>查询后是一个inline_hook</p>
<p>将strcmp的函数地址存到strcmp_0中，然后执行下面函数（sub_1150或a2即为加密函数）</p>
<p><img src="https://www.wes1.cn/_astro/image-20251108205129255.BXtI86aW_ZPPEeB.webp" alt="image-20251108205129255" /></p>
<p>9727转hex为0x25ff，转小端ff 25为jmp的字节码，小端存进qword src[0]的低四位，</p>
<p>两行结束src[0]为00 00 00 00 ff 25 00 00 ，</p>
<p>&lt;!--         highword|lowword(小端序)      --&gt;</p>
<p>第三行从第七位00开始换为a2的地址，构建出src为jmp a2的指令，</p>
<p>再将新的src地址赋给*lpadress,即strcmp_0的地址,即原来库函数strcmp的地址，</p>
<p>&lt;!--改指针不用管执行顺序，直接相当与将指向库函数strcmp的指针strcmp_0指向了jmp a2；--&gt;</p>
<p>这样就完成了对strcmp的hook动态替换。</p>
]]></content>
    <author>
      <name>wes1meanon</name>
    </author>
    <category term="CTF"></category>
  </entry>
  <entry>
    <title>逆向作业#2</title>
    <link href="https://www.wes1.cn/posts/moectf_flower/" rel="alternate" type="text/html"/>
    <id>https://www.wes1.cn/posts/moectf_flower/</id>
    <published>2025-11-06T00:00:00.000Z</published>
    <updated>2025-11-06T00:00:00.000Z</updated>
    <summary>校队逆向作业#2：反调试</summary>
    <content type="html"><![CDATA[<h1><strong>flower</strong></h1>
<h2>0x00   动调</h2>
<p>elf文件,idawsl动调无法正常运行,提示Don't trace me:(,猜测有反调试.</p>
<p><img src="https://www.wes1.cn/_astro/image-20251105151711679.CkOj-k2U_1Soq47.webp" alt="image-20251105151711679" /></p>
<h2>0x01   去花</h2>
<p>ida发现标红，无法f5,track到有很明显的花,4048e5处jz和jnz必有一个执行,所以call永不执行</p>
<p><img src="https://www.wes1.cn/_astro/image-20251105150024312.vKO0Eqy8_Z1KGf6X.webp" alt="image-20251105150024312" /></p>
<p>直接nop掉call,然后选中标红段按c强转为code,找到函数头按u再按p重定义,即可正常f5</p>
<p><img src="https://www.wes1.cn/_astro/image-20251105152045437.i2mYFawr_T7oFp.webp" alt="image-20251105152045437" /></p>
<h2>0x02  去反调试</h2>
<p>对主函数按x向上追溯,发现这里第24行的cin没有执行,下第10行的断点后调试,发现在check中会跳出</p>
<p><img src="https://www.wes1.cn/_astro/image-20251105153916779.DDp-69eU_Xlwoe.webp" alt="image-20251105153916779" /></p>
<p>进入发现ptrace反调试函数,if(调试)就进入下面的块</p>
<p><img src="https://www.wes1.cn/_astro/image-20251105154220679.CoXArOKP_vetFy.webp" alt="image-20251105154220679" /></p>
<p>直接让他不进入即可,将jz改为jmp</p>
<p><img src="https://www.wes1.cn/_astro/image-20251105173120318.DYPYhdRU_ZfX3Vn.webp" alt="image-20251105173120318" /></p>
<p>然后就可以正常调试了,solve加密函数也能正常显示</p>
<p><img src="https://www.wes1.cn/_astro/image-20251105173318497.2cYpZxX9_1Q1WM6.webp" alt="image-20251105173318497" /></p>
<h2>0x03 解密</h2>
<p>encode函数就是将输入自增,异或和与enc中比较</p>
<p>解密代码:</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;

unsigned int encflag[] = {0x4F,0x1A,0x59,0x1F,0x5B,0x1D,0x5D,0x6F,0x7B,0x47,0x7E,0x44,0x6A,0x7,0x59,0x67,0xE,0x52,0x8,0x63,0x5C,0x1A,0x52,0x1F,0x20,0x7B,0x21,0x77,0x70,0x25,0x74,0x2B,0x44};

int main()
{
    unsigned int key = 0x23;
    

​    for(int i = 0; i &lt; 32; i++)
​    {
​        encflag[i] ^= key;
​        key++;
​        cout&lt;&lt;char((encflag[i]&lt;&lt;24)&amp;0xFF);
​    }
​    return 0;

}
</code></pre>
<p>解完发现不对:111l&gt;|9|5tEPkSjE7hU=f=Uk"k%</p>
<p>构造跳过验证moectf{}和内部32位长度,动调过去发现key最后被修改为0x29(函数内自增了一次)</p>
<p><img src="https://www.wes1.cn/_astro/image-20251106145307003.D-yomDIe_ZNm4PA.webp" alt="image-20251106145307003" /></p>
<pre><code>#include&lt;iostream&gt;

#include&lt;string&gt;

#include&lt;algorithm&gt;

#include&lt;vector&gt;

using namespace std;

unsigned int encflag[] = {0x4F,0x1A,0x59,0x1F,0x5B,0x1D,0x5D,0x6F,0x7B,0x47,0x7E,0x44,0x6A,0x7,0x59,0x67,0xE,0x52,0x8,0x63,0x5C,0x1A,0x52,0x1F,0x20,0x7B,0x21,0x77,0x70,0x25,0x74,0x2B};

int main()

{

  unsigned int key = 0x29;


  for(int i = 0; i &lt; 32; i++)

  {

​    encflag[i] ^= key;

​    key++;

​    printf("%c",char((encflag[i])&amp;0xFF));

  }

  return 0;

}
</code></pre>
<p>解得f0r3v3r_JuMp_1n_7h3_a$m_a9b35c3c,套上验证moectf{}即可;</p>
<h1><strong>test</strong></h1>
<h2>0x00 调试</h2>
<p>发现flag似乎一闪而过</p>
<h2>0x01 下断点</h2>
<p>主函数中什么也没有,尝试下断点动态调试,最终找到进入了这样的函数<img src="https://www.wes1.cn/_astro/image-20251105171058080.Dfo2iEdw_1ywDqe.webp" alt="image-20251105171058080" /></p>
<p>再断在clear之前,显示出flag</p>
<p><img src="https://www.wes1.cn/_astro/image-20251105171232060.C6yC0L1v_Z15GotX.webp" alt="image-20251105171232060" /></p>
<p>flag{Wow_Y0u_f1nd_me_in_init_array!}</p>
]]></content>
    <author>
      <name>wes1meanon</name>
    </author>
    <category term="CTF"></category>
  </entry>
</feed>